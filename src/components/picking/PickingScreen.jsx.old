import React, { useState, useEffect, useRef, useMemo, useCallback, memo } from 'react';
import { motion, AnimatePresence, LayoutGroup } from 'framer-motion';
import { 
  Package, 
  Target,
  CheckCircle,
  AlertCircle,
  Zap,
  Star,
  ShoppingCart,
  Barcode,
  CalendarDays,
  BarChart3,
  Layers,
  ScanLine,
  MapPin,
  Navigation,
  Clock,
  TrendingUp,
  Minus,
  Plus,
  Edit2,
  Check,
  AlertTriangle,
  Sparkles,
  ChevronDown,
  ChevronUp,
  Eye,
  EyeOff,
  GripVertical,
  ArrowLeft,
  RefreshCw
} from 'lucide-react';

import ScanInput from '../ScanInput';
import PickingTimer from './PickingTimer';
import PriorityBadge from '../PriorityBadge';
import ProgressRing from '../ProgressRing.jsx';
import BackButton from '../BackButton';
import GameIcon from '../GameIcon';
import { playSound, initializeAudio, isAudioInitialized } from '../../utils/audio';
import { formatDate, formatTime } from '../../utils/formatters';
import { useDebounce } from '../../hooks/useDebounce';
import { useBatchedUpdates } from '../../hooks/useBatchedUpdates';
import OptimizedPickingItem from './OptimizedPickingItem';
import VirtualGrid from '../VirtualGrid';

// Import comprehensive icon mapping from central constants
import { getItemIconType } from '../../config/gameIconConstants';

// Helper function to render mixed GameIcons representing different item types as ONE batch
const renderMixedGameIcons = (items, totalCount, size = 48, isForTierGuide = false) => {
  // If totalCount is 0, show a default scanner GameIcon with actualQuantity 1 to force display
  if (totalCount === 0) {
    return (
      <GameIcon 
        iconType="camera"
        iconCount={1}
        actualQuantity={1}
        size={size}
        iconSize="medium"
        showBadge={false}
        tier="standard" // Force a visible tier
      />
    );
  }
  
  // Get unique item types from all items
  const uniqueItemTypes = [...new Set(items.map(item => getItemIconType(item.name, item.id)))];
  
  // Limit to 3-4 different icon types to avoid clutter
  const displayTypes = uniqueItemTypes.slice(0, 4);
  
  // Force correct tier for specific quantities in the tier guide
  let forcedTier = null;
  if (totalCount === 1) forcedTier = 'normal';
  else if (totalCount === 5) forcedTier = 'standard';
  else if (totalCount === 25) forcedTier = 'super';
  else if (totalCount === 125) forcedTier = 'mega';
  
  // For the tier guide, show mixed icons with forced tier
  if (isForTierGuide && forcedTier) {
    return (
      <GameIcon 
        iconType="box" // Fallback type, won't be used since we're using mixedIconTypes
        iconCount={1} // Single icon to show tier color
        actualQuantity={1} // Match iconCount
        size={size}
        iconSize="medium"
        showBadge={false}
        mixedIconTypes={displayTypes} // Keep the custom item icons
        tier={forcedTier} // Force tier for specific quantities
      />
    );
  }
  
  // For non-guide usage, use mixed icons
  return (
    <GameIcon 
      iconType="box" // Fallback type, won't be used since we're using mixedIconTypes
      iconCount={totalCount} // Use total count for tier system
      actualQuantity={totalCount} // Explicitly pass actualQuantity to ensure correct tier calculation
      size={size}
      iconSize="medium"
      showBadge={false}
      mixedIconTypes={displayTypes} // Pass mixed types as single batch
      tier={forcedTier} // Force tier for specific quantities
    />
  );
};

// Animated barcode visual for specific messages
const AnimatedBarcode = ({ color = "bg-blue-400" }) => (
  <div className="flex items-center space-x-1 ml-2">
    {[...Array(8)].map((_, i) => (
      <motion.div
        key={i}
        className={color}
        style={{ 
          width: Math.random() > 0.5 ? '2px' : '4px',
          height: '20px'
        }}
        animate={{ 
          opacity: [0.3, 1, 0.3],
          scaleY: [0.8, 1.2, 0.8]
        }}
        transition={{
          duration: 1.5,
          repeat: Infinity,
          delay: i * 0.1,
          ease: "easeInOut"
        }}
      />
    ))}
  </div>
);

// Animated placeholder component with input feedback
const AnimatedPlaceholder = ({ inputValue, isTyping, isFocused, justClicked }) => {
  const placeholderTexts = [
    "Zap the barcodes âš¡",
    "Beep boop incoming",
    "Scanner hungry for data",
    "Ready to laser stuff",
    "Seeking striped friends",
    "Barcode detector activated",
    "Loading epic scans",
    "Waiting for magic codes",
    "Beam me up some data",
    "Scanning for treasures"
  ];

  const clickFeedback = [
    "Let's scan something ðŸŽ¯",
    "Ready to rock ðŸš€", 
    "Game time âš¡",
    "Scanning mode: ON ðŸ”¥",
    "Let's do this ðŸ’ª"
  ];

  const focusFeedback = [
    "I'm listening ðŸ‘‚",
    "Ready for input ðŸ“",
    "Type away âŒ¨ï¸",
    "What's the barcode ðŸ¤”",
    "Scanner activated ðŸŽ¯"
  ];

  const typingFeedback = [
    "Nice! Keep going...",
    "Almost there...",
    "Looking good! ðŸŽ¯",
    "Perfect! One more...",
    "Excellent scanning! âš¡",
    "You're on fire! ðŸ”¥"
  ];

  const [currentIndex, setCurrentIndex] = useState(0);
  const [typingIndex, setTypingIndex] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setCurrentIndex((prev) => {
        let nextIndex;
        do {
          nextIndex = Math.floor(Math.random() * placeholderTexts.length);
        } while (nextIndex === prev && placeholderTexts.length > 1);
        return nextIndex;
      });
    }, 3000);
    return () => clearInterval(interval);
  }, [placeholderTexts.length]);

  // Change typing feedback based on input length
  useEffect(() => {
    if (isTyping && inputValue.length > 0) {
      const index = Math.min(inputValue.length - 1, typingFeedback.length - 1);
      setTypingIndex(index);
    }
  }, [inputValue.length, isTyping]);

  const WaveDots = () => (
    <span className="inline-flex ml-1">
      {[0, 1, 2].map((i) => (
        <motion.span
          key={i}
          animate={{ y: [0, -3, 0] }}
          transition={{
            duration: 0.6,
            repeat: Infinity,
            delay: i * 0.15,
            ease: "easeInOut"
          }}
          className="inline-block"
        >
          .
        </motion.span>
      ))}
    </span>
  );


  // Excited scanner dots when typing
  const ExcitedDots = () => (
    <span className="inline-flex ml-1">
      {[0, 1, 2].map((i) => (
        <motion.span
          key={i}
          animate={{ 
            y: [0, -3, 0],
            scale: [1, 1.08, 1]
          }}
          transition={{
            duration: 0.4,
            repeat: Infinity,
            delay: i * 0.12,
            ease: [0.4, 0, 0.6, 1]
          }}
          className="inline-block text-[#3A86B6]"
        >
          !
        </motion.span>
      ))}
    </span>
  );

  // Animated exclamation marks
  const AnimatedExclamation = () => (
    <span className="inline-flex ml-1">
      <motion.span
        animate={{ 
          y: [0, -4, 0],
          scale: [1, 1.2, 1],
          rotate: [0, -10, 10, 0]
        }}
        transition={{
          duration: 0.6,
          repeat: Infinity,
          ease: "easeInOut"
        }}
        className="inline-block text-[#3A86B6] font-bold"
      >
        !
      </motion.span>
    </span>
  );

  // Animated question mark
  const AnimatedQuestion = () => (
    <span className="inline-flex ml-1">
      <motion.span
        animate={{ 
          y: [0, -3, 0],
          scale: [1, 1.15, 1],
          rotate: [0, -5, 5, 0]
        }}
        transition={{
          duration: 0.8,
          repeat: Infinity,
          ease: "easeInOut"
        }}
        className="inline-block text-[#3A86B6] font-bold"
      >
        ?
      </motion.span>
    </span>
  );

  // Loading dots specifically for "Loading epic scans..."
  const LoadingDots = () => (
    <span className="inline-flex ml-1">
      {[0, 1, 2].map((i) => (
        <motion.span
          key={i}
          animate={{ 
            opacity: [0.3, 1, 0.3],
            scale: [0.8, 1.2, 0.8]
          }}
          transition={{
            duration: 1.2,
            repeat: Infinity,
            delay: i * 0.4,
            ease: "easeInOut"
          }}
          className="inline-block text-[#3A86B6]"
        >
          .
        </motion.span>
      ))}
    </span>
  );

  // Track previous selections and current display text
  const [lastClickText, setLastClickText] = useState('');
  const [lastFocusText, setLastFocusText] = useState('');
  const [currentDisplayText, setCurrentDisplayText] = useState('');
  const [clickProcessed, setClickProcessed] = useState(false);
  const [isNewClickText, setIsNewClickText] = useState(false);

  // Generate random text without repetition
  const getRandomText = (textArray, lastText) => {
    if (textArray.length <= 1) return textArray[0];
    let selectedText;
    do {
      selectedText = textArray[Math.floor(Math.random() * textArray.length)];
    } while (selectedText === lastText);
    return selectedText;
  };

  // Update display text when justClicked changes
  useEffect(() => {
    if (justClicked && !clickProcessed) {
      const selectedText = getRandomText(clickFeedback, lastClickText);
      setLastClickText(selectedText);
      setCurrentDisplayText(selectedText);
      setClickProcessed(true);
      setIsNewClickText(true);
      // Reset the new click flag after animation starts
      setTimeout(() => setIsNewClickText(false), 50);
    } else if (!justClicked && clickProcessed) {
      setClickProcessed(false);
    }
  }, [justClicked, clickProcessed, lastClickText]);

  // Update display text when isFocused changes - but not if we just clicked
  useEffect(() => {
    if (isFocused && !isTyping && inputValue.length === 0 && !justClicked) {
      const selectedText = getRandomText(focusFeedback, lastFocusText);
      setLastFocusText(selectedText);
      setCurrentDisplayText(selectedText);
    }
  }, [isFocused, isTyping, inputValue.length, justClicked]);

  // Update display text for typing
  useEffect(() => {
    if (isTyping && inputValue.length > 0) {
      setCurrentDisplayText(typingFeedback[typingIndex]);
    }
  }, [isTyping, inputValue.length, typingIndex]);

  // Update display text for normal cycling - immediate update when focus is lost
  useEffect(() => {
    if (!justClicked && !isFocused && (!isTyping || inputValue.length === 0)) {
      // Immediately set the display text when transitioning back to normal cycling
      setCurrentDisplayText(placeholderTexts[currentIndex]);
    }
  }, [justClicked, isFocused, isTyping, inputValue.length, currentIndex]);

  const displayText = currentDisplayText;

  const showBarcode = !isTyping && !isFocused && !justClicked && (placeholderTexts[currentIndex].includes("Seeking striped friends") || 
                     placeholderTexts[currentIndex].includes("Barcode detector activated"));
  
  const showLoading = !isTyping && !isFocused && !justClicked && displayText.includes("Loading epic scans");

  const showExclamation = !isTyping && !isFocused && !justClicked && (displayText.includes("Zap the barcodes") || displayText.includes("Beam me up some data")) || 
    (justClicked && (displayText.includes("Let's do this") || displayText.includes("Game time") || displayText.includes("Let's scan something") || displayText.includes("Ready to rock") || displayText.includes("Scanning mode: ON"))) || 
    (isFocused && (displayText.includes("Scanner activated") || displayText.includes("Type away") || displayText.includes("Ready for input")));

  const showQuestion = isFocused && displayText.includes("What's the barcode");

  const showListeningDots = isFocused && displayText.includes("I'm listening");

  const showExcited = (isTyping && inputValue.length > 0) || justClicked || isFocused;

  // Use display text as key and track if this is a click event
  const getAnimationKey = () => {
    return `text-${displayText}`;
  };

  return (
    <motion.span
      key={getAnimationKey()}
      initial={{ 
        opacity: 0, 
        y: 6, 
        scale: isNewClickText ? 0.8 : 0.98 
      }}
      animate={{ 
        opacity: 0.9, 
        y: 0,
        scale: isNewClickText ? [0.8, 1.15, 1] : showExcited ? [1, 1.05, 1] : 1
      }}
      exit={{ opacity: 0, y: -8 }}
      transition={{ 
        duration: 0.3,
        ease: "easeInOut",
        scale: showExcited && !isNewClickText ? { duration: 0.6, repeat: Infinity, ease: "easeInOut" } : 
               isNewClickText ? { duration: 0.4, ease: "backOut", delay: 0 } : 
               { duration: 0.3, delay: 0 }
      }}
      className={`absolute font-bold pointer-events-none flex items-center drop-shadow-[0_0_10px_rgba(59,130,246,0.5)] ${
        displayText.length > 18 ? 'text-3xl' : 'text-4xl'
      } text-[#3A86B6]`}
      style={{ 
        left: '80px', 
        top: 'calc(50% - 14px)', 
        transform: 'translateY(-50%)',
        maxWidth: 'calc(100% - 160px)', // Ensure it doesn't overflow into right side
        whiteSpace: 'nowrap',
        overflow: 'hidden',
        textOverflow: 'ellipsis'
      }}
    >
      {displayText}
      {showLoading ? <AnimatedBarcode /> : showListeningDots ? <WaveDots /> : showQuestion ? <AnimatedQuestion /> : showExclamation ? <AnimatedExclamation /> : showBarcode ? <AnimatedBarcode /> : showExcited ? <ExcitedDots /> : <WaveDots />}
    </motion.span>
  );
};

const PickingScreen = memo(({ order, onComplete, initialPickedItems = [], resetSelection = false, onBack, shouldUndoLastPick = false, onUndoLastPickComplete, initialTimerSeconds = 0 }) => {
  // Define DROP_ZONE_SIZE first - make zones take up more of the screen
  const DROP_ZONE_WIDTH = window.innerWidth * 0.48; // 48% of screen width (leaves 4% gap)
  const DROP_ZONE_HEIGHT = window.innerHeight * 0.45; // 45% of screen height
  const DROP_ZONE_HEIGHT_TALL = window.innerHeight * 0.9; // 90% height for tall sections
  
  // Pre-allocated spots system - only 3 spots for 3 sections - memoized to prevent recreation
  const SPOTS = useMemo(() => [
    // Top left corner - Items to Pick (TALL)
    { id: 'top-left', x: 20, y: 80, absolute: true, width: Math.floor(DROP_ZONE_WIDTH), height: Math.floor(DROP_ZONE_HEIGHT_TALL) },
    
    // Top right corner - Completed Items
    { id: 'top-right', x: Math.floor(window.innerWidth - DROP_ZONE_WIDTH - 20), y: 80, absolute: true, width: Math.floor(DROP_ZONE_WIDTH), height: Math.floor(DROP_ZONE_HEIGHT) },
    
    // Bottom right corner - Metrics (moved from bottom left)
    { id: 'bottom-right', x: Math.floor(window.innerWidth - DROP_ZONE_WIDTH - 20), y: Math.floor(window.innerHeight - DROP_ZONE_HEIGHT - 20), absolute: true, width: Math.floor(DROP_ZONE_WIDTH), height: Math.floor(DROP_ZONE_HEIGHT) },
  ], [DROP_ZONE_WIDTH, DROP_ZONE_HEIGHT, DROP_ZONE_HEIGHT_TALL]);
  
  const [pickedItems, setPickedItems] = useState(initialPickedItems);
  // When editing (shouldUndoLastPick is true), always start timer as active
  const [timerActive, setTimerActive] = useState(shouldUndoLastPick || initialTimerSeconds === 0);
  const [timerSeconds, setTimerSeconds] = useState(initialTimerSeconds);
  const [combo, setCombo] = useState(0);
  const [showComboAnimation, setShowComboAnimation] = useState(false);
  const [perfectStreak, setPerfectStreak] = useState(true);
  const [scanSuccess, setScanSuccess] = useState(false);
  const [scanError, setScanError] = useState('');
  const [scanRemoved, setScanRemoved] = useState(false);
  const [audioStatus, setAudioStatus] = useState('unknown');

  const [selectedItemId, setSelectedItemId] = useState(null);
  const [isInteractingWithItem, setIsInteractingWithItem] = useState(false);
  
  // Wrap setSelectedItemId with logging
  const setSelectedItemIdWithLogging = useCallback((itemId, source = 'unknown') => {
    console.log(`setSelectedItemId called from ${source}:`, { 
      oldSelectedItemId: selectedItemId, 
      newSelectedItemId: itemId 
    });
    setSelectedItemId(itemId);
  }, [selectedItemId]);
  const [currentBinLocation, setCurrentBinLocation] = useState(null);
  const [removedItemId, setRemovedItemId] = useState(null);
  const [pickedItemId, setPickedItemId] = useState(null);
  const [editingQuantity, setEditingQuantity] = useState(null);
  const [tempQuantity, setTempQuantity] = useState('');
  const [inputValue, setInputValue] = useState('');
  const [showCompletedItems, setShowCompletedItems] = useState(false);
  const [showMetrics, setShowMetrics] = useState(false);
  const [showItemsToPick, setShowItemsToPick] = useState(true);
  const [isTyping, setIsTyping] = useState(false);
  const [isFocused, setIsFocused] = useState(false);
  const [justClicked, setJustClicked] = useState(false);
  
  // Dropzone contents state - which section is in which zone
  const [dropzoneContents, setDropzoneContents] = useState({
    'top': 'itemsToPick',
    'bottom-left': 'completedItems',
    'bottom-right': 'metrics'
  });
  
  // Drag states
  const [draggingSection, setDraggingSection] = useState(null);
  const [dragOverZone, setDragOverZone] = useState(null);
  const [dragPositions, setDragPositions] = useState({});
  const [dragTransform, setDragTransform] = useState({ scale: 1, x: 0, y: 0 });
  
  // Safety timeout to clear dragging state if it gets stuck
  useEffect(() => {
    if (draggingSection) {
      const timeout = setTimeout(() => {
        console.warn('Clearing stuck dragging state after timeout');
        setDraggingSection(null);
        setDragOverZone(null);
        setDragTransform({ scale: 1, x: 0, y: 0 });
      }, 5000); // 5 second timeout
      
      return () => clearTimeout(timeout);
    }
  }, [draggingSection]);
  
  // Global handlers to clear stuck dragging state
  useEffect(() => {
    const handleEscapeKey = (e) => {
      if (e.key === 'Escape' && draggingSection) {
        console.log('Clearing dragging state via Escape key');
        setDraggingSection(null);
        setDragOverZone(null);
        setDragTransform({ scale: 1, x: 0, y: 0 });
      }
    };
    
    document.addEventListener('keydown', handleEscapeKey);
    
    return () => {
      document.removeEventListener('keydown', handleEscapeKey);
    };
  }, [draggingSection]);
  
  // Refs for draggable elements
  const dragElementRefs = useRef({});

  // Manage body class during drag operations to prevent stacking context issues
  useEffect(() => {
    if (draggingSection) {
      document.body.classList.add('dragging');
    } else {
      document.body.classList.remove('dragging');
    }
    
    // Cleanup on unmount
    return () => {
      document.body.classList.remove('dragging');
    };
  }, [draggingSection]);
  
  // Dropzone sizes state - user adjustable
  const [dropzoneSizes, setDropzoneSizes] = useState({
    'top': { width: '100%', height: window.innerHeight * 0.5 },
    'bottom-left': { width: '100%', height: window.innerHeight * 0.4 },
    'bottom-right': { width: '100%', height: window.innerHeight * 0.4 }
  });
  
  // Resize states
  const [resizingZone, setResizingZone] = useState(null);
  const [resizeStartPos, setResizeStartPos] = useState({ x: 0, y: 0 });
  const [resizeStartSize, setResizeStartSize] = useState({ width: 0, height: 0 });
  
  const timerStopRef = useRef(false);
  const hasInteractedRef = useRef(false);
  const completeSoundPlayedRef = useRef(false);
  const isEditingRef = useRef(false);
  const pickedItemTimeoutRef = useRef(null);
  const removedItemTimeoutRef = useRef(null);
  const scanSuccessTimeoutRef = useRef(null);
  const inputRef = useRef(null);
  const handleRemoveItemRef = useRef(null);

  const batchUpdates = useBatchedUpdates();
  const debouncedInputValue = useDebounce(inputValue, 150);
  const isCompletingRef = useRef(false);
  
  // Check if a section is minimized
  const isSectionMinimized = useCallback((sectionId) => {
    switch (sectionId) {
      case 'itemsToPick':
        return !showItemsToPick;
      case 'completedItems':
        return !showCompletedItems;
      case 'metrics':
        return !showMetrics;
      default:
        return false;
    }
  }, [showItemsToPick, showCompletedItems, showMetrics]);

  // Handle resize start
  const handleResizeStart = useCallback((e, zoneId) => {
    e.preventDefault();
    e.stopPropagation();
    setResizingZone(zoneId);
    setResizeStartPos({ x: e.clientX, y: e.clientY });
    setResizeStartSize({ 
      width: parseFloat(dropzoneSizes[zoneId].width) || 100,
      height: dropzoneSizes[zoneId].height 
    });
  }, [dropzoneSizes]);
  
  // Handle resize move
  useEffect(() => {
    if (!resizingZone) return;
    
    const handleMouseMove = (e) => {
      const deltaX = e.clientX - resizeStartPos.x;
      const deltaY = e.clientY - resizeStartPos.y;
      
      const newWidth = Math.max(300, Math.min(window.innerWidth * 0.9, resizeStartSize.width + deltaX));
      const newHeight = Math.max(
        isSectionMinimized(dropzoneContents[resizingZone]) ? 120 : 250,
        Math.min(window.innerHeight * 0.9, resizeStartSize.height + deltaY)
      );
      
      setDropzoneSizes(prev => ({
        ...prev,
        [resizingZone]: {
          width: resizingZone === 'top' ? '100%' : `${newWidth}px`,
          height: newHeight
        }
      }));
    };
    
    const handleMouseUp = () => {
      setResizingZone(null);
    };
    
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
    
    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
  }, [resizingZone, resizeStartPos, resizeStartSize, dropzoneContents, isSectionMinimized]);


  // Timer tracking for navigation display
  useEffect(() => {
    let interval;
    if (timerActive) {
      interval = setInterval(() => {
        setTimerSeconds(prev => prev + 1);
      }, 1000);
    }
    return () => {
      if (interval) {
        clearInterval(interval);
      }
    };
  }, [timerActive]);

  // Handle undoing the last pick when coming from edit
  useEffect(() => {
    if (shouldUndoLastPick && pickedItems.length > 0) {
      // Prevent auto-complete while undoing
      completeSoundPlayedRef.current = true;
      
      // Find the last picked item
      const lastPickedItemId = pickedItems[pickedItems.length - 1];
      
      // Use handleRemoveItem to properly remove the item
      // This will be called after handleRemoveItem is defined
      if (handleRemoveItemRef.current) {
        handleRemoveItemRef.current(lastPickedItemId);
        
        // Reset the complete flag after a delay
        setTimeout(() => {
          completeSoundPlayedRef.current = false;
        }, 100);
      }
      
      // After undoing the last pick, restart the timer if it was stopped
      if (timerStopRef.current) {
        timerStopRef.current = false;
        setTimerActive(true);
        // Keep the existing timer value, don't reset to 0
      }
      
      // Notify parent that undo is complete
      if (onUndoLastPickComplete) {
        onUndoLastPickComplete();
      }
    }
  }, [shouldUndoLastPick, pickedItems.length, onUndoLastPickComplete]);

  // Memoized calculations for performance - moved here to be available for window.pickingPageData
  const totalItems = useMemo(() => {
    return order.items.reduce((sum, item) => sum + item.quantity, 0);
  }, [order.items]);

  const totalPicked = useMemo(() => {
    return pickedItems.length;
  }, [pickedItems.length]);

  const pickedCounts = useMemo(() => {
    const counts = {};
    pickedItems.forEach(id => {
      counts[id] = (counts[id] || 0) + 1;
    });
    return counts;
  }, [pickedItems]);

  // Calculated total picked for progress (capped at required quantities)
  const totalPickedForProgress = useMemo(() => {
    return order.items.reduce((sum, item) => {
      const pickedCount = pickedCounts[item.id] || 0;
      return sum + Math.min(pickedCount, item.quantity);
    }, 0);
  }, [order.items, pickedCounts]);

  const allItemsPicked = useMemo(() => {
    return order.items.every(item => {
      const pickedCount = pickedCounts[item.id] || 0;
      return pickedCount >= item.quantity;
    });
  }, [order.items, pickedCounts]);

  // Separate completed and incomplete items
  const { completedItems, incompleteItems } = useMemo(() => {
    const completed = [];
    const incomplete = [];
    
    order.items.forEach(item => {
      const pickedCount = pickedCounts[item.id] || 0;
      if (pickedCount >= item.quantity) {
        completed.push(item);
      } else {
        incomplete.push(item);
      }
    });
    
    // Sort both arrays by bin location - DEFENSIVE: Filter out null/undefined first
    const completedWithValidLocations = completed.filter(item => 
      item.binLocation && typeof item.binLocation === 'string'
    );
    const incompleteWithValidLocations = incomplete.filter(item =>
      item.binLocation && typeof item.binLocation === 'string'
    );
    
    completedWithValidLocations.sort((a, b) => a.binLocation.localeCompare(b.binLocation));
    incompleteWithValidLocations.sort((a, b) => a.binLocation.localeCompare(b.binLocation));
    
    return { completedItems: completedWithValidLocations, incompleteItems: incompleteWithValidLocations };
  }, [order.items, pickedCounts]);

  // Calculated progress for the main progress bar
  const orderProgress = useMemo(() => {
    return totalItems > 0 ? (totalPickedForProgress / totalItems) * 100 : 0;
  }, [totalItems, totalPickedForProgress]);

  // Expose data to navigation bar
  useEffect(() => {
    window.pickingPageData = {
      // FIX: Prioritize human-readable SO number fields over transformed orderId
      orderId: order?.soNumber || order?.salesOrderNumber || order?.id,
      soNumber: order?.salesOrderNumber || order?.soNumber,
      customer: order?.customer,
      timerDisplay: formatTime(timerSeconds),
      timerActive: timerActive,
      totalPicked: totalPickedForProgress, // Use progress-compatible total
      totalItems: totalItems,
      remainingItems: totalItems - totalPickedForProgress, // Calculate remaining items
      orderProgress: orderProgress,
      onBack: onBack,
      isPickingScreen: true // Flag to indicate we're in actual picking screen
    };

    // Cleanup when component unmounts
    return () => {
      // Don't delete if we're completing (going to confirmation screen)
      if (!isCompletingRef.current) {
        delete window.pickingPageData;
      }
    };
  }, [order?.soNumber, order?.salesOrderNumber, order?.id, order?.customer, 
      timerSeconds, timerActive, totalPickedForProgress, totalItems, orderProgress, onBack]);


  // Get current zone for a section
  const getCurrentZone = useCallback((sectionId) => {
    for (const [zone, section] of Object.entries(dropzoneContents)) {
      if (section === sectionId) return zone;
    }
    return null;
  }, [dropzoneContents]);


  // Handle swapping sections between dropzones
  const handleSectionSwap = useCallback((targetZone, draggedSection) => {
    setDropzoneContents(prev => {
      const newContents = { ...prev };
      
      // Find where the dragged section currently is
      let sourceZone = null;
      Object.entries(prev).forEach(([zone, section]) => {
        if (section === draggedSection) {
          sourceZone = zone;
        }
      });
      
      if (sourceZone) {
        if (sourceZone !== targetZone) {
          // Normal swap for cross-zone drops
          const targetSection = prev[targetZone];
          newContents[targetZone] = draggedSection;
          newContents[sourceZone] = targetSection;
        }
        // Always play success sound for any valid drop (same zone or cross zone)
        playSound('success');
      }
      
      return newContents;
    });
  }, []);

  // Handle drag end with better zone detection and validation
  const handleDragEndWithZoneDetection = useCallback((event, info, sectionId) => {
    try {
      // Use the pointer position for more accurate detection
      const pointerX = event.clientX || (event.touches && event.touches[0]?.clientX) || 0;
      const pointerY = event.clientY || (event.touches && event.touches[0]?.clientY) || 0;
      
      // Find which dropzone we're over based on pointer position
      const dropzones = document.querySelectorAll('[data-dropzone]');
      let targetZone = null;
      let bestZone = null;
      let bestOverlap = 0;
      
      // Check all dropzones and find the one with most overlap
      dropzones.forEach(zone => {
        const zoneRect = zone.getBoundingClientRect();
        const zoneId = zone.getAttribute('data-dropzone');
        
        // Calculate overlap area for more robust detection
        const overlapLeft = Math.max(pointerX - 50, zoneRect.left);
        const overlapRight = Math.min(pointerX + 50, zoneRect.right);
        const overlapTop = Math.max(pointerY - 50, zoneRect.top);
        const overlapBottom = Math.min(pointerY + 50, zoneRect.bottom);
        
        if (overlapLeft < overlapRight && overlapTop < overlapBottom) {
          const overlapArea = (overlapRight - overlapLeft) * (overlapBottom - overlapTop);
          if (overlapArea > bestOverlap) {
            bestOverlap = overlapArea;
            bestZone = zoneId;
          }
        }
        
        // Also check simple point-in-rect for immediate detection
        if (pointerX >= zoneRect.left && pointerX <= zoneRect.right &&
            pointerY >= zoneRect.top && pointerY <= zoneRect.bottom) {
          targetZone = zoneId;
        }
      });
      
      // Use the target zone if found, otherwise use best overlap zone
      const finalZone = targetZone || bestZone;
      
      // Check if we have a valid zone
      if (finalZone && dropzoneContents.hasOwnProperty(finalZone)) {
        const currentZone = getCurrentZone(sectionId);
        
        if (finalZone !== currentZone) {
          // Different zone - perform swap and prevent snap-back
          handleSectionSwap(finalZone, sectionId);
          return true;
        } else {
          // Same zone - still call handleSectionSwap for sound effect, but allow snap-back
          handleSectionSwap(finalZone, sectionId);
          return false; // This allows dragSnapToOrigin to work
        }
      }
      
      // Return false to indicate snap-back should occur
      return false;
    } catch (error) {
      console.warn('Error in drag end detection:', error);
      return false;
    } finally {
      // Always ensure drag state is cleared
      setDraggingSection(null);
      setDragOverZone(null);
      setDragTransform({ scale: 1, x: 0, y: 0 });
    }
  }, [getCurrentZone, handleSectionSwap, dropzoneContents]);

  // Handle typing detection
  useEffect(() => {
    if (inputValue.length > 0) {
      setIsTyping(true);
      const timeout = setTimeout(() => {
        if (inputValue.length === 0) {
          setIsTyping(false);
        }
      }, 1000);
      return () => clearTimeout(timeout);
    } else {
      setIsTyping(false);
    }
  }, [inputValue]);

  

  // Handle click feedback timeout
  useEffect(() => {
    if (justClicked) {
      const timeout = setTimeout(() => {
        setJustClicked(false);
      }, 2000);
      return () => clearTimeout(timeout);
    }
  }, [justClicked]);

  // Calculate scale and absolute position for dropzone preview
  const getDropzoneTransform = useCallback((targetZone, currentZone, sectionId) => {
    const defaultTransform = { scale: 1.05, x: 0, y: 0 };
    
    if (!targetZone) return defaultTransform; // Default when not over any zone
    
    // Get target dropzone, current dropzone, and dragged element
    const targetElement = document.querySelector(`[data-dropzone="${targetZone}"]`);
    const currentElement = document.querySelector(`[data-dropzone="${currentZone}"]`);
    const draggedElement = dragElementRefs.current[sectionId];
    
    if (!targetElement || !currentElement) {
      // Fallback to static scales based on known dropzone types
      const scale = (() => {
        switch (targetZone) {
          case 'top':
            return 0.8; // Items to Pick is large - scale down more
          case 'bottom-left':
          case 'bottom-right':
            return 1.3; // Smaller zones - scale up more
          default:
            return 1.05;
        }
      })();
      return { scale, x: 0, y: 0 };
    }
    
    // Get dimensions
    const targetRect = targetElement.getBoundingClientRect();
    const currentRect = currentElement.getBoundingClientRect();
    
    // Calculate scale based on target dropzone size vs current element size
    let scale = 1.05; // Default scale
    
    if (draggedElement) {
      const elementRect = draggedElement.getBoundingClientRect();
      // Scale based on target dropzone size vs actual element size
      const widthScale = (targetRect.width * 0.85) / elementRect.width; // 0.85 for padding
      const heightScale = (targetRect.height * 0.85) / elementRect.height;
      const calculatedScale = Math.min(widthScale, heightScale);
      scale = Math.max(0.5, Math.min(1.8, calculatedScale)); // Wider range for more dramatic scaling
    } else {
      // Fallback: compare dropzone dimensions with more dramatic scaling
      const widthRatio = targetRect.width / currentRect.width;
      const heightRatio = targetRect.height / currentRect.height;
      const calculatedScale = Math.min(widthRatio, heightRatio);
      scale = Math.max(0.5, Math.min(1.8, calculatedScale));
    }
    
    // Calculate absolute position to move to target dropzone center
    const targetCenterX = targetRect.left + targetRect.width / 2;
    const targetCenterY = targetRect.top + targetRect.height / 2;
    
    const currentCenterX = currentRect.left + currentRect.width / 2;
    const currentCenterY = currentRect.top + currentRect.height / 2;
    
    // Calculate the absolute offset needed to center on target dropzone
    const x = targetCenterX - currentCenterX;
    const y = targetCenterY - currentCenterY;
    
    return { scale, x, y };
  }, []);

  // Input event handlers
  const handleInputClick = () => {
    setJustClicked(true);
    setIsInteractingWithItem(true);
    playSound('click');
  };

  const handleInputFocus = () => {
    setIsFocused(true);
    setIsInteractingWithItem(true);
    playSound('hover');
  };

  const handleInputBlur = () => {
    setIsFocused(false);
    setIsInteractingWithItem(false);
    // Clear justClicked immediately when losing focus to prevent delay
    setJustClicked(false);
  };


  // Reset timer state when returning to picking screen
  useEffect(() => {
    if (allItemsPicked && initialPickedItems.length > 0) {
      // If we're returning to picking with all items already picked, stop the timer
      timerStopRef.current = true;
      setTimerActive(false);
    }
  }, []);

  // Reset selection when explicitly requested (e.g., from edit button)
  useEffect(() => {
    if (resetSelection) {
      setSelectedItemId(null);
    }
  }, [resetSelection]);

  // Debug: Log when selectedItemId changes
  useEffect(() => {
  }, [selectedItemId]);

  // Cleanup timeouts on unmount
  useEffect(() => {
    return () => {
      if (pickedItemTimeoutRef.current) {
        clearTimeout(pickedItemTimeoutRef.current);
      }
      if (removedItemTimeoutRef.current) {
        clearTimeout(removedItemTimeoutRef.current);
      }
      if (scanSuccessTimeoutRef.current) {
        clearTimeout(scanSuccessTimeoutRef.current);
      }
    };
  }, []);

  // Audio initialization
  useEffect(() => {
    const handleInteraction = async (e) => {
      if (isAudioInitialized()) return;
      
      
      const success = await initializeAudio();
      if (success) {
        setAudioStatus('initialized');
        setTimeout(() => playSound('click'), 100);
      } else {
        setAudioStatus('failed');
      }
      
      document.removeEventListener('click', handleInteraction);
      document.removeEventListener('touchstart', handleInteraction);
      document.removeEventListener('keydown', handleInteraction);
    };
    
    if (isAudioInitialized()) {
      setAudioStatus('initialized');
    } else {
      document.addEventListener('click', handleInteraction);
      document.addEventListener('touchstart', handleInteraction);
      document.addEventListener('keydown', handleInteraction);
    }
    
    return () => {
      document.removeEventListener('click', handleInteraction);
      document.removeEventListener('touchstart', handleInteraction);
      document.removeEventListener('keydown', handleInteraction);
    };
  }, []);

  // Find the optimal next item in picking order (for Next tag)
  const getOptimalNextItem = useCallback(() => {
    // Sort items by bin location for optimal picking path
    const sortedItems = [...order.items].sort((a, b) => 
      a.binLocation.localeCompare(b.binLocation)
    );
    
    for (const item of sortedItems) {
      const pickedCount = pickedItems.filter(id => id === item.id).length;
      if (pickedCount < item.quantity) {
        return item;
      }
    }
    return null;
  }, [order.items, pickedItems]);

  // Find next item to pick (prioritizes selected item for actions)
  const getNextItemToPick = () => {
    // First check if there's a selected item that still needs picking
    if (selectedItemId) {
      const selectedItem = order.items.find(i => i.id === selectedItemId);
      if (selectedItem) {
        const pickedCount = pickedItems.filter(id => id === selectedItemId).length;
        if (pickedCount < selectedItem.quantity) {
          return selectedItem;
        }
      }
    }
    
    // If no selected item or selected item is complete, use optimal picking order
    return getOptimalNextItem();
  };

  const nextItem = getNextItemToPick();
  const optimalNextItem = getOptimalNextItem();

  // Helper function to manage scan success state with proper cleanup
  const setScanSuccessWithTimeout = (success) => {
    // Clear any existing timeout
    if (scanSuccessTimeoutRef.current) {
      clearTimeout(scanSuccessTimeoutRef.current);
      scanSuccessTimeoutRef.current = null;
    }
    
    setScanSuccess(success);
    
    if (success) {
      scanSuccessTimeoutRef.current = setTimeout(() => {
        setScanSuccess(false);
        scanSuccessTimeoutRef.current = null;
      }, 1500);
    }
  };

  // Set current bin location based on next item
  useEffect(() => {
    if (nextItem) {
      setCurrentBinLocation(nextItem.binLocation);
    }
  }, [nextItem]);

  // Auto-select first incomplete item on mount
  useEffect(() => {
    if (!selectedItemId && !resetSelection) {
      const firstIncompleteItem = getOptimalNextItem();
      if (firstIncompleteItem) {
        setSelectedItemId(firstIncompleteItem.id);
      }
    }
  }, [selectedItemId, getOptimalNextItem, resetSelection]);

  const validateScan = (scannedSKU) => {
    // Match by item ID first, then SKU, then barcode for maximum compatibility
    const item = order.items.find(i => i.id === scannedSKU || i.sku === scannedSKU || i.barcode === scannedSKU);
    if (!item) {
      return false;
    }
    
    const pickedCount = pickedItems.filter(id => id === scannedSKU).length;
    if (pickedCount >= item.quantity) {
      return false;
    }
    
    return true;
  };

  const handleItemScan = (scannedSKU) => {
    hasInteractedRef.current = true; // Mark that user has interacted
    
    // Match by item ID first, then SKU, then barcode for maximum compatibility
    const item = order.items.find(i => i.id === scannedSKU || i.sku === scannedSKU || i.barcode === scannedSKU);
    if (!item) {
      setCombo(0);
      setPerfectStreak(false);
      setScanError(`Invalid item! "${scannedSKU}" is not in this order.`);
      setScanSuccessWithTimeout(false);
      setTimeout(() => setScanError(''), 2000);
      playSound('error');
      return;
    }

    const pickedCount = pickedItems.filter(id => id === scannedSKU).length;
    if (pickedCount >= item.quantity) {
      setScanError(`Already picked all ${item.quantity} of ${item.name}`);
      setScanSuccessWithTimeout(false);
      setTimeout(() => setScanError(''), 2000);
      playSound('error');
      return;
    }

    // Add SKU to pickedItems (not UUID)
    setPickedItems([...pickedItems, scannedSKU]);
    setCombo(prev => prev + 1);
    setScanError('');
    setScanSuccessWithTimeout(true);
    
    // Auto-select the scanned item for visual feedback (unless we're resetting)
    if (!resetSelection) {
      setSelectedItemId(scannedSKU);
    }
    
    // Check if the scanned item is now fully picked
    const newPickedCount = pickedItems.filter(id => id === scannedSKU).length + 1;
    const isItemNowComplete = newPickedCount >= item.quantity;
    
    // Auto-advance to next incomplete item after a delay
    if (isItemNowComplete) {
      // Calculate the updated picked items list
      const updatedPickedItems = [...pickedItems, scannedSKU];
      
      setTimeout(() => {
        // Find next item based on updated picked items
        const sortedItems = [...order.items].sort((a, b) => 
          a.binLocation.localeCompare(b.binLocation)
        );
        
        let nextItem = null;
        for (const item of sortedItems) {
          const pickedCount = updatedPickedItems.filter(id => id === item.id).length;
          if (pickedCount < item.quantity) {
            nextItem = item;
            break;
          }
        }
        
        if (nextItem) {
          setSelectedItemId(nextItem.id);
          playSound('click');
        }
      }, 1000);
    }
    
    if (combo > 0 && combo % 5 === 0) {
      setShowComboAnimation(true);
      playSound('combo');
      setTimeout(() => setShowComboAnimation(false), 1000);
    } else if (isItemNowComplete) {
      // Play powerup sound when item is fully picked
      playSound('powerup');
    } else {
      playSound('success');
    }

    // Visual effect: flash green for successful pick
    setPickedItemId(scannedSKU);
    setTimeout(() => setPickedItemId(null), 350);
    
    const newPickedItems = [...pickedItems, scannedSKU];
    const allPicked = order.items.every(item => {
      const count = newPickedItems.filter(id => id === item.id).length;
      return count >= item.quantity;
    });

    if (allPicked && !timerStopRef.current) {
      timerStopRef.current = true;
      setTimerActive(false);
    }
  };

  // Handle item click for selection (picking workflow)
  const handleItemClick = (itemId) => {
    console.log('handleItemClick called:', { 
      itemId, 
      currentSelectedItemId: selectedItemId, 
      isAlreadySelected: selectedItemId === itemId 
    });
    
    // Find item by ID, SKU, or barcode for maximum compatibility
    const item = order.items.find(i => i.id === itemId || i.sku === itemId || i.barcode === itemId);
    if (!item) {
      console.error('Item not found in order:', itemId);
      playSound('error');
      return;
    }

    const pickedCount = pickedItems.filter(id => id === itemId).length;
    
    // If item is fully picked, just play error sound
    if (pickedCount >= item.quantity) {
      playSound('error');
      return;
    }
    
    // Always use consistent behavior: first click selects, second click picks
    if (selectedItemId !== itemId) {
      // First click: select the item
      console.log('Selecting item:', itemId);
      setSelectedItemIdWithLogging(itemId, 'handleItemClick');
      playSound('click');
    } else {
      // Second click on same item: pick it
      console.log('Picking already selected item:', itemId);
      handleItemScan(itemId);
    }
  };

  // Handle mouse down on items to track interaction
  const handleItemMouseDown = useCallback(() => {
    setIsInteractingWithItem(true);
    
    // Failsafe: reset after 3 seconds if still stuck
    const timeoutId = setTimeout(() => {
      setIsInteractingWithItem(false);
    }, 3000);
    
    // Clear timeout on cleanup
    return () => clearTimeout(timeoutId);
  }, []);
  
  // Handle mouse up globally to reset interaction state
  useEffect(() => {
    const handleMouseUp = () => {
      setIsInteractingWithItem(false);
    };
    
    const handleMouseLeave = (e) => {
      // Reset interaction state when mouse leaves the picking screen area
      if (!e.relatedTarget || !e.currentTarget.contains(e.relatedTarget)) {
        setIsInteractingWithItem(false);
      }
    };
    
    window.addEventListener('mouseup', handleMouseUp);
    window.addEventListener('touchend', handleMouseUp);
    document.addEventListener('mouseleave', handleMouseLeave);
    
    // Also reset on escape key
    const handleEscape = (e) => {
      if (e.key === 'Escape') {
        setIsInteractingWithItem(false);
        setDraggingSection(null);
      }
    };
    window.addEventListener('keydown', handleEscape);
    
    return () => {
      window.removeEventListener('mouseup', handleMouseUp);
      window.removeEventListener('touchend', handleMouseUp);
      document.removeEventListener('mouseleave', handleMouseLeave);
      window.removeEventListener('keydown', handleEscape);
    };
  }, []);

  const isItemFullyPicked = useCallback((itemId) => {
    const item = order.items.find(i => i.id === itemId);
    const pickedCount = pickedCounts[itemId] || 0;
    return pickedCount >= item.quantity;
  }, [order.items, pickedCounts]);

  const isItemPartiallyPicked = useCallback((itemId) => {
    const pickedCount = pickedCounts[itemId] || 0;
    return pickedCount > 0 && !isItemFullyPicked(itemId);
  }, [pickedCounts, isItemFullyPicked]);

  const getPickedCount = useCallback((itemId) => {
    return pickedCounts[itemId] || 0;
  }, [pickedCounts]);

  const handleAddItem = useCallback((itemId, e) => {
    if (e) {
      e.stopPropagation(); // Prevent triggering the card click
      e.preventDefault(); // Also prevent default behavior
    }
    hasInteractedRef.current = true; // Mark that user has interacted
    
    const item = order.items.find(i => i.id === itemId);
    const currentCount = getPickedCount(itemId);
    
    if (currentCount < item.quantity) {
      batchUpdates(() => {
        setPickedItems(prev => [...prev, itemId]);
        setScanError('');
        setScanRemoved(false);
        setPickedItemId(itemId);
        if (!resetSelection) {
          setSelectedItemId(itemId);
        }
      });
      
      setScanSuccessWithTimeout(true);
      playSound('scan');
      
      // Visual effect
      setTimeout(() => setPickedItemId(null), 350);
      
      const newPickedItems = [...pickedItems, itemId];
      
      // Check if this item is now fully picked
      const newPickedCount = newPickedItems.filter(id => id === itemId).length;
      const isItemNowComplete = newPickedCount >= item.quantity;
      
      // Auto-advance to next incomplete item after a delay
      if (isItemNowComplete) {
        setTimeout(() => {
          // Find next item based on updated picked items
          const sortedItems = [...order.items].sort((a, b) => 
            a.binLocation.localeCompare(b.binLocation)
          );
          
          let nextItem = null;
          for (const sortItem of sortedItems) {
            const pickedCount = newPickedItems.filter(id => id === sortItem.id).length;
            if (pickedCount < sortItem.quantity) {
              nextItem = sortItem;
              break;
            }
          }
          
          if (nextItem) {
            setSelectedItemId(nextItem.id);
            playSound('click');
          }
        }, 1000);
      }
      
      const allPicked = order.items.every(item => {
        const count = newPickedItems.filter(id => id === item.id).length;
        return count >= item.quantity;
      });

      if (allPicked && !timerStopRef.current) {
        timerStopRef.current = true;
        setTimerActive(false);
      }
    } else {
      playSound('error');
    }
  }, [order.items, getPickedCount, pickedItems, batchUpdates, resetSelection]);

  const handleRemoveItem = useCallback((itemId, e) => {
    if (e) {
      e.stopPropagation(); // Prevent triggering the card click
      e.preventDefault(); // Also prevent default behavior
    }
    hasInteractedRef.current = true; // Mark that user has interacted
    
    const currentCount = getPickedCount(itemId);
    const item = order.items.find(i => i.id === itemId);
    const wasFullyPicked = currentCount >= item.quantity;
    
    if (currentCount > 0) {
      // Flash red for removed item
      setRemovedItemId(itemId);
      if (removedItemTimeoutRef.current) {
        clearTimeout(removedItemTimeoutRef.current);
      }
      removedItemTimeoutRef.current = setTimeout(() => {
        setRemovedItemId(null);
        removedItemTimeoutRef.current = null;
      }, 500);

      batchUpdates(() => {
        setPickedItems(prev => {
          const index = prev.lastIndexOf(itemId);
          if (index > -1) {
            const newItems = [...prev];
            newItems.splice(index, 1);
            
            // Check if item will become incomplete after removal
            const newCount = newItems.filter(id => id === itemId).length;
            const willBeIncomplete = newCount < item.quantity;
            
            // If item was fully picked and will now be incomplete, auto-select it
            if (wasFullyPicked && willBeIncomplete && !resetSelection) {
              setTimeout(() => {
                setSelectedItemId(itemId);
                playSound('click');
              }, 100);
            }
            
            return newItems;
          }
          return prev;
        });
        setScanError('');
        setScanSuccess(false);
        setScanRemoved(true);
      });
      
      setTimeout(() => setScanRemoved(false), 1500);
      playSound('error');
      
      // Restart timer if it was stopped
      if (timerStopRef.current) {
        timerStopRef.current = false;
        setTimerActive(true);
      }
    } else {
      playSound('error');
    }
  }, [getPickedCount, batchUpdates]);

  // Assign handleRemoveItem to ref so it can be used in effects
  useEffect(() => {
    handleRemoveItemRef.current = handleRemoveItem;
  }, [handleRemoveItem]);

  const handleEditQuantity = useCallback((itemId, newQuantity) => {
    if (newQuantity === undefined) {
      // Start edit mode
      console.log('Starting edit mode for item:', itemId);
      setEditingQuantity(itemId);
      // Auto-select the item when entering edit mode
      if (!resetSelection) {
        setSelectedItemIdWithLogging(itemId, 'handleEditQuantity-start');
      }
      return;
    }
    
    // Finish edit mode and apply the new quantity
    console.log('Finishing edit mode for item:', itemId, 'with quantity:', newQuantity);
    setEditingQuantity(null);
    setTempQuantity('');
    isEditingRef.current = true; // Flag that we just finished editing
    
    hasInteractedRef.current = true; // Mark that user has interacted
    
    const item = order.items.find(i => i.id === itemId);
    const currentCount = getPickedCount(itemId);
    const wasFullyPicked = currentCount >= item.quantity;
    
    if (newQuantity >= 0 && newQuantity <= item.quantity) {
      // Calculate difference and update picked items
      const difference = newQuantity - currentCount;
      
      batchUpdates(() => {
        if (difference > 0) {
          // Add items
          const itemsToAdd = Array(difference).fill(itemId);
          setPickedItems(prev => [...prev, ...itemsToAdd]);
          setPickedItemId(itemId);
          setTimeout(() => setPickedItemId(null), 350);
          setScanSuccessWithTimeout(true);
        } else if (difference < 0) {
          // Remove items
          setPickedItems(prev => {
            const newItems = [...prev];
            let toRemove = Math.abs(difference);
            for (let i = newItems.length - 1; i >= 0 && toRemove > 0; i--) {
              if (newItems[i] === itemId) {
                newItems.splice(i, 1);
                toRemove--;
              }
            }
            return newItems;
          });
          setRemovedItemId(itemId);
          setTimeout(() => setRemovedItemId(null), 350);
          setScanRemoved(true);
          setTimeout(() => setScanRemoved(false), 1500);
          
          // If item was fully picked and will now be incomplete, auto-select it
          const willBeIncomplete = newQuantity < item.quantity;
          if (wasFullyPicked && willBeIncomplete && !resetSelection) {
            setTimeout(() => {
              setSelectedItemId(itemId);
              playSound('click');
            }, 100);
          }
        }
        
        setScanError('');
        setEditingQuantity(null);
        setTempQuantity('');
        
        if (!resetSelection) {
          setSelectedItemId(itemId);
        }
      });
      
      if (difference !== 0) {
        playSound(difference > 0 ? 'success' : 'error');
      }
      
      isEditingRef.current = true; // Flag that we just finished editing
      
      // Check if all items are picked after this change
      const newPickedItems = [...pickedItems];
      if (difference > 0) {
        newPickedItems.push(...Array(difference).fill(itemId));
      } else if (difference < 0) {
        let toRemove = Math.abs(difference);
        for (let i = newPickedItems.length - 1; i >= 0 && toRemove > 0; i--) {
          if (newPickedItems[i] === itemId) {
            newPickedItems.splice(i, 1);
            toRemove--;
          }
        }
      }
      
      // Check if this item is now fully picked
      const isItemNowComplete = newQuantity >= item.quantity;
      
      // Auto-advance to next incomplete item after a delay
      if (isItemNowComplete && difference > 0) {
        setTimeout(() => {
          // Find next item based on updated picked items
          const sortedItems = [...order.items].sort((a, b) => 
            a.binLocation.localeCompare(b.binLocation)
          );
          
          let nextItem = null;
          for (const sortItem of sortedItems) {
            const pickedCount = newPickedItems.filter(id => id === sortItem.id).length;
            if (pickedCount < sortItem.quantity) {
              nextItem = sortItem;
              break;
            }
          }
          
          if (nextItem) {
            setSelectedItemId(nextItem.id);
            playSound('click');
          }
        }, 1000);
      }
      
      const allPicked = order.items.every(item => {
        const count = newPickedItems.filter(id => id === item.id).length;
        return count >= item.quantity;
      });

      if (allPicked && !timerStopRef.current) {
        timerStopRef.current = true;
        setTimerActive(false);
      } else if (!allPicked && timerStopRef.current) {
        timerStopRef.current = false;
        setTimerActive(true);
      }
    }
  }, [order.items, getPickedCount, pickedItems, batchUpdates, resetSelection]);

  const handleTempQuantityChange = useCallback((value) => {
    setTempQuantity(value);
  }, []);

  const handleOnEditingRef = useCallback(() => isEditingRef, []);

  // Handle form submission for barcode scanning
  const handleScanSubmit = (e) => {
    e.preventDefault();
    if (inputValue.trim()) {
      handleItemScan(inputValue.trim());
      setInputValue('');
    }
  };

  // Handle refreshing sections
  const handleRefreshSection = useCallback((sectionId) => {
    playSound('click');
    
    switch (sectionId) {
      case 'itemsToPick':
        // Refresh items to pick - reset picked counts and re-render
        const refreshedPickedCounts = {};
        order.items.forEach(item => {
          const pickedCount = pickedCounts[item.id] || 0;
          refreshedPickedCounts[item.id] = pickedCount;
        });
        setPickedCounts({ ...refreshedPickedCounts });
        break;
        
      case 'completedItems':
        // Force re-render of completed items
        setShowCompletedItems(false);
        setTimeout(() => setShowCompletedItems(true), 100);
        break;
        
      case 'metrics':
        // Force re-render of metrics
        setShowMetrics(false);
        setTimeout(() => setShowMetrics(true), 100);
        break;
        
      default:
        break;
    }
  }, [order.items, pickedCounts]);

  // Complete order when all items are picked
  useEffect(() => {
    if (allItemsPicked && hasInteractedRef.current && !completeSoundPlayedRef.current) {
      completeSoundPlayedRef.current = true;
      setTimeout(() => {
        playSound('levelup');
        setTimeout(() => {
          const stats = {
            time: timerSeconds,
            pickedItems: pickedItems,
            accuracy: 100, // Assuming 100% accuracy for now
            totalItems: order.totalItems
          };
          isCompletingRef.current = true;
          onComplete(stats);
        }, 1000);
      }, 500);
    }
  }, [allItemsPicked, onComplete, pickedItems, timerSeconds, order.totalItems]);

  // Determine how many items still need to be picked
  const remainingItemCount = useMemo(() => {
    return order.items.reduce((total, item) => {
      const pickedCount = pickedCounts[item.id] || 0;
      const remaining = Math.max(0, item.quantity - pickedCount);
      return total + remaining;
    }, 0);
  }, [order.items, pickedCounts]);

  // Move hasAnimated to component level to follow Rules of Hooks
  const hasAnimated = useMemo(() => ({}), []);

  // Grid rendering function with virtualization
  const renderItemGrid = useCallback((items, isMinimized = false, sectionId = null) => {
    // Dynamic container height based on current zone and section states
    const zone = getCurrentZone(sectionId);
    // Use reasonable fixed heights that allow content to be visible without forcing huge containers
    let containerHeight;
    const isExpanded = (sectionId === 'itemsToPick' && showItemsToPick) ||
                      (sectionId === 'completedItems' && showCompletedItems) ||
                      (sectionId === 'metrics' && showMetrics);
    
    if (isExpanded) {
      // When expanded, provide enough height for content
      const isInBottomZone = zone === 'bottom-left' || zone === 'bottom-right';
      
      if (isInBottomZone) {
        // Check if completed items is next to items to pick
        const isCompletedNextToItems = 
          (sectionId === 'completedItems' && 
           ((zone === 'bottom-left' && dropzoneContents['bottom-right'] === 'itemsToPick') ||
            (zone === 'bottom-right' && dropzoneContents['bottom-left'] === 'itemsToPick')));
        
        // Check if metrics is next to items to pick
        const isMetricsNextToItems = 
          (sectionId === 'metrics' && 
           ((zone === 'bottom-left' && dropzoneContents['bottom-right'] === 'itemsToPick') ||
            (zone === 'bottom-right' && dropzoneContents['bottom-left'] === 'itemsToPick')));
        
        if (isCompletedNextToItems) {
          // Make completed items taller when next to items to pick
          containerHeight = 805;
        } else if (isMetricsNextToItems) {
          // Make metrics even taller when next to items to pick
          containerHeight = 850;
        } else {
          // Use consistent height for all sections in bottom dropzones
          containerHeight = 680; // Same height for alignment
        }
      } else {
        // Top zone can have different heights
        if (sectionId === 'itemsToPick') {
          containerHeight = Math.min(600, window.innerHeight * 0.6); // Cap at 600px or 60% viewport
        } else if (sectionId === 'completedItems') {
          containerHeight = 680; // Fine-tuned to perfectly match metrics
        } else {
          containerHeight = Math.min(500, window.innerHeight * 0.5); // Metrics can be slightly smaller
        }
      }
    } else {
      // When collapsed, use smaller heights
      containerHeight = 250; // Fixed height for collapsed state
    }
    
    // Maintain stable layout for all sections
    const displayItems = items;
    
    return (
      <div className="h-full flex flex-col">
        <VirtualGrid
          items={displayItems}
          itemsPerRow={zone === 'top' ? 3 : 2}
          itemHeight={(() => {
            if (isMinimized) {
              // Completed items need more height to match their min-h-[320px] + padding
              return sectionId === 'completedItems' ? 320 : 220;
            }
            // Adjust item height based on zone
            if (zone !== 'top') {
              // For bottom dropzones, use consistent height for both sections
              return sectionId === 'completedItems' ? 400 : 400;
            }
            // For top zone
            return sectionId === 'completedItems' ? 450 : 450;
          })()}
          containerHeight={containerHeight}
          gap={sectionId === 'itemsToPick' ? (zone === 'top' ? 32 : 20) : 20}
          rowGap={(() => {
            if (sectionId === 'itemsToPick') {
              return 160; // Same large gap for all zones
            } else if (sectionId === 'completedItems') {
              return zone === 'top' ? 60 : 40; // Reduced gap for bottom dropzones to fit more items
            }
            return 30; // Default for other sections
          })()}
          overscan={2}
          renderItem={(item, index) => (
            <motion.div
              key={item.id}
              initial={{ opacity: 0, scale: 0.8 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.8 }}
              transition={{ duration: 0.2 }}
            >
              <OptimizedPickingItem
                key={item.id}
                item={item}
                pickedCount={getPickedCount(item.id)}
                isSelected={selectedItemId === item.id}
                isFullyPicked={isItemFullyPicked(item.id)}
                isPartiallyPicked={isItemPartiallyPicked(item.id)}
                isNextToPick={selectedItemId === item.id && !isItemFullyPicked(item.id)}
                hasAnimated={hasAnimated[item.id]}
                index={index}
                removedItemId={removedItemId}
                pickedItemId={pickedItemId}
                editingQuantity={editingQuantity}
                tempQuantity={tempQuantity}
                isDragging={!!draggingSection}
                onItemClick={handleItemClick}
                isMinimized={isMinimized}
                isCompact={zone !== 'top'}
                sectionId={sectionId}
                onAddItem={handleAddItem}
                onRemoveItem={handleRemoveItem}
                onEditQuantity={handleEditQuantity}
                onTempQuantityChange={handleTempQuantityChange}
                onEditingRef={handleOnEditingRef}
                onMouseDown={handleItemMouseDown}
              />
            </motion.div>
          )}
        />
      </div>
    );
  }, [
    getPickedCount, selectedItemId, isItemFullyPicked, isItemPartiallyPicked, 
    optimalNextItem, removedItemId, pickedItemId, editingQuantity, tempQuantity,
    handleItemClick, handleAddItem, handleRemoveItem, handleEditQuantity, 
    handleTempQuantityChange, handleOnEditingRef, DROP_ZONE_HEIGHT_TALL, DROP_ZONE_HEIGHT,
    getCurrentZone, showCompletedItems, showMetrics, showItemsToPick, draggingSection
  ]);

  // Section content components
  const renderSectionContent = useCallback((sectionId) => {
    switch (sectionId) {
      case 'itemsToPick':
        return (
          <>
            <div className="flex items-center space-x-3">
              <GripVertical className="text-[#3A86B6]/60" size={20} />
              <ScanLine className="text-[#3A86B6]" size={24} />
              <h3 className="text-4xl font-bold text-white">Items to Pick</h3>
              <div className="bg-[#3A86B6]/20 border border-[#3A86B6]/50 px-3 py-1 rounded-full">
                <motion.span 
                  key={incompleteItems.length}
                  initial={{ scale: 0.8, opacity: 0 }}
                  animate={{ scale: 1, opacity: 1 }}
                  transition={{ duration: 0.2 }}
                  className="text-blue-300 font-bold"
                >
                  {incompleteItems.length} items
                </motion.span>
              </div>
            </div>
          </>
        );
      
      case 'completedItems':
        return completedItems.length > 0 ? (
          <>
            <div className="flex items-center space-x-3">
              <GripVertical className="text-green-400/60" size={20} />
              <CheckCircle className="text-green-400" size={24} />
              <h3 className="text-4xl font-bold text-white">Completed Items</h3>
              <div className="bg-green-500/20 border border-green-500/50 px-3 py-1 rounded-full">
                <motion.span 
                  key={completedItems.length}
                  initial={{ scale: 0.8, opacity: 0 }}
                  animate={{ scale: 1, opacity: 1 }}
                  transition={{ duration: 0.2 }}
                  className="text-green-300 font-bold"
                >
                  {completedItems.length} completed
                </motion.span>
              </div>
            </div>
          </>
        ) : null;
      
      case 'metrics':
        return (
          <>
            <div className="flex items-center space-x-3">
              <GripVertical className="text-purple-400/60" size={allSectionsMinimized ? 24 : 20} />
              <BarChart3 className="text-purple-400" size={allSectionsMinimized ? 32 : 24} />
              <h3 className="text-xl font-bold text-[#E6EAF0]">Metrics & Guide</h3>
              <div className="bg-purple-500/20 border border-purple-500/50 px-2 py-0.5 rounded-full">
                <span className="text-purple-300 font-bold text-sm">Stats & Tiers</span>
              </div>
            </div>
          </>
        );
      
      default:
        return null;
    }
  }, [incompleteItems.length, completedItems.length]);

  const getSectionConfig = useCallback((sectionId) => {
    switch (sectionId) {
      case 'itemsToPick':
        return {
          id: 'itemsToPick',
          show: showItemsToPick,
          setShow: setShowItemsToPick,
          bgColor: 'bg-gray-900/30 backdrop-blur-md hover:shadow-2xl hover:shadow-[#3A86B6]/20 border-gray-700/55 hover:border-[#3A86B6]/50',
          chevronColor: 'text-[#3A86B6]',
          visible: true, // Always show items to pick section
          content: (
            <div className="flex flex-col h-full">
              {/* Barcode Scanner - only show when expanded */}
              {showItemsToPick && (
                <div className="mb-6">
                <motion.form 
                  onSubmit={handleScanSubmit}
                  className="relative"
                >
                  <div className="relative bg-gradient-to-r from-[#3A86B6]/10 to-[#2A7696]/10 p-1 rounded-xl">
                    <div className="relative bg-gray-900 rounded-lg">
                      {/* Animated scan icon */}
                      <div className="absolute left-6 top-1/2 -translate-y-1/2 w-12 h-12 flex items-center justify-center">
                        <motion.div
                          animate={{ 
                            scale: [1, 1.15, 1],
                            opacity: [0.8, 1, 0.8],
                            rotate: [0, 5, -5, 0]
                          }}
                          transition={{ 
                            duration: 3, 
                            repeat: Infinity,
                            ease: "easeInOut"
                          }}
                          className="flex items-center justify-center"
                        >
                          <ScanLine className={`transition-all duration-200 drop-shadow-lg ${
                            scanSuccess 
                              ? 'text-green-400'
                              : scanRemoved
                              ? 'text-red-400' 
                              : scanError
                              ? 'text-red-400' 
                              : 'text-[#3A86B6]'
                          }`} size={40} />
                        </motion.div>
                      </div>
                      
                      {/* Animated placeholder when empty */}
                      {!inputValue && !scanSuccess && !scanError && !scanRemoved && (
                        <AnimatePresence>
                          <AnimatedPlaceholder 
                            inputValue={inputValue} 
                            isTyping={isTyping} 
                            isFocused={isFocused} 
                            justClicked={justClicked}
                          />
                        </AnimatePresence>
                      )}
                      
                      <input
                        ref={inputRef}
                        type="text"
                        value={inputValue}
                        onChange={(e) => setInputValue(e.target.value)}
                        onFocus={handleInputFocus}
                        onBlur={handleInputBlur}
                        onClick={handleInputClick}
                        onMouseDown={() => setIsInteractingWithItem(true)}
                        placeholder=""
                        autoComplete="off"
                        autoFocus
                        className={`w-full pl-20 pr-16 h-24 text-left bg-gray-800 border-2 ${
                          scanSuccess 
                            ? 'border-green-500 ring-4 ring-green-500/30 bg-green-900/60' 
                            : scanRemoved
                            ? 'border-red-500 ring-4 ring-red-500/30 bg-red-900/60'
                            : scanError
                            ? 'border-red-500 ring-4 ring-red-500/30 bg-red-900/60' 
                            : 'border-[#3A86B6] focus:ring-4 focus:ring-blue-500/40 focus:border-[#3A86B6] hover:border-[#4A96C6] hover:bg-gray-800/90'
                        } rounded-xl text-white outline-none transition-all duration-200 text-3xl font-mono shadow-lg caret-blue-500`}
                        style={{ lineHeight: '1.5' }}
                      />
                      
                      {/* Status messages overlay */}
                      {(scanSuccess || scanError || scanRemoved) && (
                        <motion.span
                          initial={{ opacity: 0, scale: 0.9 }}
                          animate={{ opacity: 1, scale: 1 }}
                          exit={{ opacity: 0, scale: 0.9 }}
                          className={`absolute left-[80px] text-3xl font-bold pointer-events-none ${
                            scanSuccess ? 'text-green-400' : scanRemoved ? 'text-red-400' : 'text-red-400'
                          }`}
                          style={{ top: 'calc(50% - 12px)', transform: 'translateY(-50%)' }}
                        >
                          {scanSuccess ? (
                            "Picked!"
                          ) : scanRemoved ? (
                            "Removed!"
                          ) : (
                            <span className="flex items-center">
                              Not a valid
                              <AnimatedBarcode color="bg-red-400" />
                              !
                            </span>
                          )}
                        </motion.span>
                      )}
                      
                      {/* Status indicator */}
                      <motion.div
                        className="absolute right-6 top-1/2 -translate-y-1/2"
                        animate={
                          scanSuccess || scanError || scanRemoved
                            ? { scale: [0, 1.2, 1] }
                            : { 
                                opacity: [0.3, 1, 0.3],
                                scale: [0.95, 1.05, 0.95]
                              }
                        }
                        transition={
                          scanSuccess || scanError || scanRemoved
                            ? { duration: 0.3 }
                            : { 
                                duration: 2, 
                                repeat: Infinity,
                                ease: "easeInOut"
                              }
                        }
                      >
                        {scanSuccess ? (
                          <Check className="text-green-400" size={20} />
                        ) : scanRemoved ? (
                          <Minus className="text-red-400" size={20} />
                        ) : scanError ? (
                          <AlertCircle className="text-red-400" size={20} />
                        ) : (
                          <Target className="text-[#3A86B6]" size={20} />
                        )}
                      </motion.div>
                    </div>
                  </div>
                </motion.form>
                </div>
              )}
              
              {/* Items Grid - Only show incomplete items when expanded */}
              {showItemsToPick && (
                <div className="flex-1 overflow-auto" 
                     onPointerDown={(e) => e.stopPropagation()}
                     onMouseDown={(e) => e.stopPropagation()}
                     onDragStart={(e) => e.preventDefault()}>
                  {incompleteItems.length > 0 ? (
                    renderItemGrid(incompleteItems, false, 'itemsToPick')
                  ) : (
                    <div className="flex items-center justify-center h-full">
                      <div className="text-center">
                        <CheckCircle className="mx-auto mb-4 text-green-400" size={64} />
                        <p className="text-2xl font-bold text-green-400">All items picked!</p>
                        <p className="text-gray-400 mt-2">Check the Completed Items section</p>
                      </div>
                    </div>
                  )}
                </div>
              )}
            </div>
          )
        };
      
      case 'completedItems':
        return {
          id: 'completedItems',
          show: showCompletedItems,
          setShow: setShowCompletedItems,
          bgColor: 'bg-gray-900/30 backdrop-blur-md hover:shadow-2xl hover:shadow-green-500/20 border-gray-700/55 hover:border-green-500/50',
          chevronColor: 'text-green-400',
          visible: completedItems.length > 0, // Only show when there are completed items
          content: showCompletedItems ? (
            <div className="flex flex-col h-full">
              {completedItems.length > 0 ? (
                renderItemGrid(completedItems, false, 'completedItems')
              ) : null}
            </div>
          ) : null
        };
      
      case 'metrics':
        return {
          id: 'metrics',
          show: showMetrics,
          setShow: setShowMetrics,
          bgColor: 'bg-gray-900/30 backdrop-blur-md hover:shadow-2xl hover:shadow-purple-500/20 border-gray-700/55 hover:border-purple-500/50',
          chevronColor: 'text-purple-400',
          visible: true,
          content: showMetrics ? (
            (() => {
              const zone = getCurrentZone('metrics');
              const isInBottomZone = zone === 'bottom-left' || zone === 'bottom-right';
              
              // Check if metrics is next to items to pick
              const isMetricsNextToItems = isInBottomZone && 
                ((zone === 'bottom-left' && dropzoneContents['bottom-right'] === 'itemsToPick') ||
                 (zone === 'bottom-right' && dropzoneContents['bottom-left'] === 'itemsToPick'));
              
              // Dynamic min-height based on whether it's next to items to pick
              const minHeight = isMetricsNextToItems ? '800px' : '550px';
              
              return (
                <div className={`flex flex-col h-full overflow-auto p-4`} style={{ minHeight }}>
                  {/* Metrics Grid */}
                  <div className="grid grid-cols-3 gap-4 flex-shrink-0 mb-6">
                <div className="bg-[#151A20] backdrop-blur-xl rounded-lg p-3 text-center border border-[#1F2630]">
                  <div className="flex justify-center mb-2">
                    {renderMixedGameIcons(order.items, totalPicked, 48)}
                  </div>
                  <p className="text-xl font-bold text-[#E6EAF0]">{totalPicked}</p>
                  <p className="text-xs text-[#A0A7B4]">Items Scanned</p>
                </div>

                <div className="bg-[#151A20] backdrop-blur-xl rounded-lg p-3 text-center border border-[#1F2630]">
                  <div className="flex justify-center mb-2">
                    <GameIcon
                      iconType="star"
                      iconCount={totalItems}
                      size={48}
                      iconSize="medium"
                      showBadge={false}
                    />
                  </div>
                  <p className="text-xl font-bold text-[#E6EAF0]">{totalItems}</p>
                  <p className="text-xs text-[#A0A7B4]">Total Items</p>
                </div>

                <div className="bg-[#151A20] backdrop-blur-xl rounded-lg p-3 text-center border border-[#1F2630]">
                  <div className="flex justify-center mb-2">
                    {order.items.filter(item => isItemFullyPicked(item.id)).length === 0 ? (
                      <div className="w-12 h-12 flex items-center justify-center">
                        <svg width="48" height="48" viewBox="0 0 96 96" fill="none">
                          <circle
                            cx="48"
                            cy="48"
                            r="40"
                            fill="url(#greenGradient)"
                            stroke="#16a34a"
                            strokeWidth="8"
                          />
                          <defs>
                            <linearGradient id="greenGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                              <stop offset="0%" stopColor="#22c55e" />
                              <stop offset="100%" stopColor="#16a34a" />
                            </linearGradient>
                          </defs>
                        </svg>
                      </div>
                    ) : (
                      <GameIcon
                        iconType="check"
                        iconCount={order.items.filter(item => isItemFullyPicked(item.id)).length}
                        size={48}
                        iconSize="medium"
                        showBadge={false}
                      />
                    )}
                  </div>
                  <p className="text-xl font-bold text-[#E6EAF0]">
                    {order.items.filter(item => isItemFullyPicked(item.id)).length}/{order.items.length}
                  </p>
                  <p className="text-xs text-[#A0A7B4]">SKUs Complete</p>
                </div>
              </div>

              {/* GameIcon Tier Guide */}
              <div className={`flex-1 bg-gradient-to-r from-purple-500/10 to-pink-500/10 border border-purple-500/30 rounded-lg p-3 shadow-lg shadow-purple-500/20 flex flex-col ${isInBottomZone ? 'min-h-[200px]' : 'min-h-0'}`}>
                <div className="flex items-center justify-center mb-2">
                  <Sparkles className="text-purple-400 mr-1.5" size={14} />
                  <h3 className="text-sm font-semibold text-purple-300">Item Tier Colors</h3>
                </div>

                <div className="flex-1 grid grid-cols-2 md:grid-cols-4 gap-3 content-center items-center min-h-0">
                  <div className="flex items-center space-x-2">
                    {renderMixedGameIcons(order.items, 1, 60, true)}
                    <span className="text-[#E6EAF0] text-lg font-bold">= 1</span>
                  </div>

                  <div className="flex items-center space-x-2">
                    {renderMixedGameIcons(order.items, 5, 60, true)}
                    <span className="text-[#E6EAF0] text-lg font-bold">= 5</span>
                  </div>

                  <div className="flex items-center space-x-2">
                    {renderMixedGameIcons(order.items, 25, 60, true)}
                    <span className="text-[#E6EAF0] text-lg font-bold">= 25</span>
                  </div>

                  <div className="flex items-center space-x-2">
                    {renderMixedGameIcons(order.items, 125, 60, true)}
                    <span className="text-[#E6EAF0] text-lg font-bold">= 125</span>
                  </div>
                </div>
              </div>
            </div>
              );
            })()
          ) : (
            // Collapsed view - only show the guide
            <div>
              <div className="bg-gradient-to-r from-purple-500/10 to-pink-500/10 border border-purple-500/30 rounded-xl p-4 shadow-lg shadow-purple-500/20">
              <div className="grid grid-cols-2 md:grid-cols-4 gap-3 items-center">
                <div className="flex items-center space-x-2">
                  {renderMixedGameIcons(order.items, 1, 32, true)}
                  <span className="text-white text-sm font-bold">= 1</span>
                </div>
                
                <div className="flex items-center space-x-2">
                  {renderMixedGameIcons(order.items, 5, 32, true)}
                  <span className="text-white text-sm font-bold">= 5</span>
                </div>
                
                <div className="flex items-center space-x-2">
                  {renderMixedGameIcons(order.items, 25, 32, true)}
                  <span className="text-white text-sm font-bold">= 25</span>
                </div>
                
                <div className="flex items-center space-x-2">
                  {renderMixedGameIcons(order.items, 125, 32, true)}
                  <span className="text-white text-sm font-bold">= 125</span>
                </div>
              </div>
              </div>
            </div>
          )
        };
      
      default:
        return null;
    }
  }, [showItemsToPick, showCompletedItems, showMetrics, incompleteItems, completedItems, renderItemGrid, totalPicked, order.items, isItemFullyPicked]);

  // Check if all sections are minimized
  const allSectionsMinimized = !showItemsToPick && !showCompletedItems && !showMetrics;

  // Debug: Log dropzone contents
  useEffect(() => {
    console.log('Dropzone contents:', dropzoneContents);
  }, [dropzoneContents]);

  // Calculate header height on mount and resize
  useEffect(() => {
    const calculateHeaderHeight = () => {
      const header = document.querySelector('.glass-card.sticky');
      if (header) {
        const height = header.offsetHeight;
        document.documentElement.style.setProperty('--header-height', `${height}px`);
      }
    };

    calculateHeaderHeight();
    window.addEventListener('resize', calculateHeaderHeight);
    
    // Also calculate when the component first mounts with a slight delay
    const timer = setTimeout(calculateHeaderHeight, 100);

    return () => {
      window.removeEventListener('resize', calculateHeaderHeight);
      clearTimeout(timer);
    };
  }, []);

  return (
    <div className="w-full min-h-full relative" style={{ minHeight: 'calc(100vh - var(--header-height, 0px))' }}>

      {/* Main content area */}
      <div className="relative" style={{ minHeight: 'calc(100vh - var(--header-height, 0px))' }}>

        {/* Dropzone Grid Container */}
        <div className="relative z-20">
            <motion.div 
              className={`p-4 ${allSectionsMinimized ? 'flex flex-col space-y-2 max-w-4xl mx-auto' : 'gap-4 grid grid-cols-1 lg:grid-cols-2'}`} 
              style={{ minHeight: 'calc(100vh - var(--header-height, 0px) - 2rem)' }}
              initial={false}
              animate={{ opacity: 1 }}
              transition={{ duration: 0.3, ease: "easeInOut" }}>
            {/* Items to Pick Dropzone */}
            <motion.div 
              className={`${!allSectionsMinimized ? 'lg:col-span-2' : ''}`}
              initial={false}
              animate={{ opacity: 1 }}
              transition={{ duration: 0.3, ease: "easeInOut" }}>
              <div 
                data-dropzone="top"
                className={`border-2 ${allSectionsMinimized ? 'border-solid' : 'border-dashed'} rounded-2xl p-4 backdrop-blur-sm relative transition-all duration-300 flex flex-col ${
                  dragOverZone === 'top' 
                    ? 'border-[#4A96C6] bg-[#3A86B6]/20 shadow-2xl shadow-[#3A86B6]/30 animate-pulse' 
                    : draggingSection && dropzoneContents['top'] !== draggingSection
                    ? 'border-blue-300 bg-[#3A86B6]/5 shadow-lg shadow-[#3A86B6]/10'
                    : scanSuccess
                    ? 'border-green-500 bg-white/5'
                    : scanError
                    ? 'border-red-500 bg-red-500/10'
                    : scanRemoved
                    ? 'border-red-500 bg-white/5'
                    : 'border-[#3A86B6] bg-white/5'
                }`}
                style={{
                  transition: resizingZone === 'top' ? 'none' : 'all 0.3s ease'
                }}
              >
                {/* Preview placeholder when dragging over */}
                {dragOverZone === 'top' && draggingSection && dropzoneContents['top'] !== draggingSection && (
                  <motion.div
                    initial={{ opacity: 0, scale: 0.8 }}
                    animate={{ opacity: 0.5, scale: dragTransform.scale }}
                    exit={{ opacity: 0, scale: 0.8 }}
                    transition={{ duration: 0.2 }}
                    className="absolute inset-0 flex items-center justify-center pointer-events-none z-10"
                  >
                    <div className={`${
                      draggingSection === 'itemsToPick' ? 'bg-[#3A86B6]/20 border-[#4A96C6]' :
                      draggingSection === 'completedItems' ? 'bg-green-500/20 border-green-400' :
                      'bg-purple-500/20 border-purple-400'
                    } border-2 border-dashed rounded-xl w-[85%] h-[85%] flex items-center justify-center`}>
                      <span className="text-white/50 text-xl font-semibold">Drop here</span>
                    </div>
                  </motion.div>
                )}
                
                {dropzoneContents['top'] && (() => {
                  const sectionId = dropzoneContents['top'];
                  const config = getSectionConfig(sectionId);
                  if (!config || !config.visible) return null;

                  return (
                <motion.div
                  key={sectionId}
                  drag={!isInteractingWithItem}
                  dragSnapToOrigin
                  dragMomentum={false}
                  dragConstraints={{
                    left: -window.innerWidth * 0.4,
                    right: window.innerWidth * 0.4,
                    top: -window.innerHeight * 0.4,
                    bottom: window.innerHeight * 0.4
                  }}
                  dragElastic={0.1}
                  dragTransition={{ bounceStiffness: 600, bounceDamping: 30 }}
                  className={`relative ${draggingSection === sectionId ? 'dragging-active' : 'z-10'}`}
                  data-draggable="true"
                  layoutId={sectionId}
                  initial={false}
                  animate={{
                    opacity: 1
                  }}
                  transition={{ 
                    layout: { duration: 0.2, ease: "easeOut" },
                    opacity: { duration: 0.1 }
                  }}
                  whileDrag={{
                    scale: draggingSection === sectionId ? dragTransform.scale : 1,
                    opacity: 0.9,
                    boxShadow: "0 25px 50px -12px rgba(0, 0, 0, 0.5), 0 0 0 2px rgba(59, 130, 246, 0.5)",
                    // cursor handled by custom cursor system
                  }}
                  ref={(el) => {
                    if (el) dragElementRefs.current[sectionId] = el;
                  }}
                  onDragStart={() => {
                    if (!isInteractingWithItem) {
                      setDraggingSection(sectionId);
                      playSound('click');
                      // Set custom cursor to dragging state
                      if (window.customCursor) {
                        window.customCursor.setDragging(true);
                      }
                    }
                  }}
                  onDrag={(event, info) => {
                    if (!isInteractingWithItem) {
                      // Get current pointer/drag position
                      const pointerX = event.clientX || (event.touches && event.touches[0]?.clientX) || 0;
                      const pointerY = event.clientY || (event.touches && event.touches[0]?.clientY) || 0;
                      
                      // Find which dropzone we're over
                      const dropzones = document.querySelectorAll('[data-dropzone]');
                      let targetZone = null;
                      
                      dropzones.forEach(zone => {
                        const zoneRect = zone.getBoundingClientRect();
                        if (pointerX >= zoneRect.left && pointerX <= zoneRect.right &&
                            pointerY >= zoneRect.top && pointerY <= zoneRect.bottom) {
                          const zoneId = zone.getAttribute('data-dropzone');
                          // Only highlight if this section can be dropped here (not its current zone)
                          if (dropzoneContents[zoneId] !== sectionId) {
                            targetZone = zoneId;
                          }
                        }
                      });
                      
                      setDragOverZone(targetZone);
                    }
                  }}
                  onDragEnd={(event, info) => {
                    if (!isInteractingWithItem) {
                      const shouldSnapBack = !handleDragEndWithZoneDetection(event, info, sectionId);
                      if (shouldSnapBack) {
                        // Force snap back to origin for same-zone drops
                        const element = dragElementRefs.current[sectionId];
                        if (element) {
                          element.style.transform = 'translate3d(0px, 0px, 0px)';
                        }
                      }
                      // Reset custom cursor dragging state
                      if (window.customCursor) {
                        window.customCursor.setDragging(false);
                      }
                    }
                  }}
                >
                  <motion.div 
                    className={`h-full w-full flex flex-col transition-all duration-300 ${config.bgColor} border rounded-xl overflow-hidden group`}
                    animate={{
                      boxShadow: config.show ? 
                        (sectionId === 'itemsToPick' ? '0 0 30px rgba(59, 130, 246, 0.3)' :
                         sectionId === 'metrics' ? '0 0 30px rgba(249, 115, 22, 0.3)' :
                         '0 0 30px rgba(16, 185, 129, 0.3)') :
                        '0 0 0px rgba(0, 0, 0, 0)',
                      borderColor: 'rgba(255, 255, 255, 0.1)'
                    }}
                    whileHover={{
                      borderColor: sectionId === 'itemsToPick' ? '#60a5fa' : 
                                 sectionId === 'metrics' ? '#fb923c' : '#34d399',
                      scale: 1.005
                    }}
                    transition={{ duration: 0.3 }}
                  >
                    <motion.button
                      onClick={() => {
                        // Prevent toggling show/hide when dragging
                        if (!draggingSection) {
                          config.setShow(!config.show);
                          playSound('click');
                        }
                      }}
                      className={`flex items-center justify-between w-full p-3 transition-all duration-300 cursor-move relative overflow-hidden border border-white/20 rounded-t-xl -m-px`}
                      whileHover={{ 
                        scale: 1.01,
                        boxShadow: "0 10px 30px -5px rgba(0, 0, 0, 0.3)",
                        borderColor: sectionId === 'itemsToPick' ? '#60a5fa' : 
                                   sectionId === 'metrics' ? '#fb923c' : '#34d399'
                      }}
                      whileTap={{ 
                        scale: 0.98,
                        transition: { duration: 0.1 }
                      }}
                      animate={{
                        borderColor: 'rgba(255, 255, 255, 0.2)'
                      }}
                      transition={{ duration: 0.3 }}
                    >
                      {/* Gradient overlay effects with state-based animation */}
                      {sectionId === 'itemsToPick' && (
                        <motion.div 
                          className="absolute inset-0 rounded-xl transition-all duration-500" 
                          animate={{
                            background: config.show ? 
                              'linear-gradient(to bottom right, rgba(59, 130, 246, 0.15), rgba(59, 130, 246, 0.05), rgba(59, 130, 246, 0.15))' :
                              'linear-gradient(to bottom right, rgba(59, 130, 246, 0), rgba(59, 130, 246, 0), rgba(59, 130, 246, 0))'
                          }}
                          whileHover={{
                            background: 'linear-gradient(to bottom right, rgba(59, 130, 246, 0.2), rgba(59, 130, 246, 0.1), rgba(59, 130, 246, 0.2))'
                          }}
                        />
                      )}
                      {sectionId === 'metrics' && (
                        <motion.div 
                          className="absolute inset-0 rounded-xl transition-all duration-500" 
                          animate={{
                            background: config.show ? 
                              'linear-gradient(to bottom right, rgba(249, 115, 22, 0.15), rgba(249, 115, 22, 0.05), rgba(249, 115, 22, 0.15))' :
                              'linear-gradient(to bottom right, rgba(249, 115, 22, 0), rgba(249, 115, 22, 0), rgba(249, 115, 22, 0))'
                          }}
                          whileHover={{
                            background: 'linear-gradient(to bottom right, rgba(249, 115, 22, 0.2), rgba(249, 115, 22, 0.1), rgba(249, 115, 22, 0.2))'
                          }}
                        />
                      )}
                      {sectionId === 'completedItems' && (
                        <motion.div 
                          className="absolute inset-0 rounded-xl transition-all duration-500" 
                          animate={{
                            background: config.show ? 
                              'linear-gradient(to bottom right, rgba(16, 185, 129, 0.15), rgba(16, 185, 129, 0.05), rgba(16, 185, 129, 0.15))' :
                              'linear-gradient(to bottom right, rgba(16, 185, 129, 0), rgba(16, 185, 129, 0), rgba(16, 185, 129, 0))'
                          }}
                          whileHover={{
                            background: 'linear-gradient(to bottom right, rgba(16, 185, 129, 0.2), rgba(16, 185, 129, 0.1), rgba(16, 185, 129, 0.2))'
                          }}
                        />
                      )}
                      {renderSectionContent(sectionId)}
                      <div className="flex items-center space-x-2">
                      {/* Refresh button */}
                      <motion.div
                        onClick={(e) => {
                          e.stopPropagation();
                          handleRefreshSection(sectionId);
                        }}
                        className={`p-1.5 rounded-lg ${config.bgColor} hover:bg-white/10 transition-all duration-200 cursor-pointer`}
                        whileHover={{ scale: 1.1 }}
                        whileTap={{ scale: 0.9 }}
                        title="Refresh section"
                      >
                        <RefreshCw className={config.chevronColor} size={18} />
                      </motion.div>
                      
                      <span className={`${config.chevronColor} text-sm font-medium opacity-80`}>
                        {config.show ? 'Hide' : 'Show'}
                      </span>
                      <motion.div
                        animate={{ 
                          rotate: config.show ? 180 : 0,
                          scale: config.show ? 1.1 : 1
                        }}
                        transition={{ 
                          duration: 0.3,
                          type: "spring",
                          stiffness: 200,
                          damping: 15
                        }}
                        whileHover={{ scale: 1.2 }}
                        whileTap={{ scale: 0.9 }}
                      >
                        {config.show ? (
                          <ChevronUp className={`${config.chevronColor} drop-shadow-sm`} size={20} />
                        ) : (
                          <ChevronDown className={`${config.chevronColor} drop-shadow-sm`} size={20} />
                        )}
                      </motion.div>
                    </div>
                    </motion.button>
                    
                    <AnimatePresence mode="wait">
                      {config.show && config.content && (
                        <motion.div 
                          className={`flex-1 overflow-hidden flex flex-col relative`}
                          initial={{ opacity: 0 }}
                          animate={{ opacity: 1 }}
                          exit={{ opacity: 0 }}
                          transition={{ 
                            opacity: { duration: 0.2, ease: "easeOut" }
                          }}
                          layout={false}
                          style={{ 
                            maxHeight: config.show ? '9999px' : '0',
                            transition: 'max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1)'
                          }}
                          onPointerDown={(e) => e.stopPropagation()}
                          onMouseDown={(e) => e.stopPropagation()}
                          onDragStart={(e) => e.preventDefault()}
                        >
                          {/* Gradient overlay effects for content area */}
                          {sectionId === 'itemsToPick' && (
                            <div className="absolute inset-0 bg-gradient-to-br from-blue-500/0 via-blue-500/0 to-blue-500/0 group-hover:from-blue-500/6 group-hover:via-blue-500/2 group-hover:to-blue-500/6 rounded-xl transition-all duration-500 pointer-events-none" />
                          )}
                          {sectionId === 'metrics' && (
                            <div className="absolute inset-0 bg-gradient-to-br from-purple-500/0 via-purple-500/0 to-purple-500/0 group-hover:from-purple-500/6 group-hover:via-purple-500/2 group-hover:to-purple-500/6 rounded-xl transition-all duration-500 pointer-events-none" />
                          )}
                          {sectionId === 'completedItems' && (
                            <div className="absolute inset-0 bg-gradient-to-br from-green-500/0 via-green-500/0 to-green-500/0 group-hover:from-green-500/6 group-hover:via-green-500/2 group-hover:to-green-500/6 rounded-xl transition-all duration-500 pointer-events-none" />
                          )}
                          <motion.div 
                            className="flex-1 p-4 overflow-auto relative z-10"
                            initial={{ opacity: 0, y: -10 }}
                            animate={{ opacity: 1, y: 0 }}
                            exit={{ opacity: 0, y: -10 }}
                            transition={{ duration: 0.2, delay: 0.1 }}
                          >
                            {config.content}
                          </motion.div>
                        </motion.div>
                      )}
                    </AnimatePresence>
                  </motion.div>
                </motion.div>
              );
            })()}
              </div>
            </motion.div>
            
            {/* Bottom Left Dropzone - Show when assigned, but hide only if it's completed items with no items */}
            {dropzoneContents['bottom-left'] && (dropzoneContents['bottom-left'] !== 'completedItems' || completedItems.length > 0) && (
              <motion.div 
                className={`${!allSectionsMinimized && (!dropzoneContents['bottom-right'] || (dropzoneContents['bottom-right'] === 'completedItems' && completedItems.length === 0)) ? 'lg:col-span-2' : ''}`}
                initial={false}
                animate={{ opacity: 1 }}
                transition={{ duration: 0.3, ease: "easeInOut" }}>
                <div 
                  data-dropzone="bottom-left"
                  className={`border-2 ${allSectionsMinimized ? 'border-solid' : 'border-dashed'} rounded-2xl p-4 backdrop-blur-sm relative transition-all duration-300 flex flex-col ${
                  dragOverZone === 'bottom-left' 
                    ? 'border-green-400 bg-green-500/20 shadow-2xl shadow-green-500/30 animate-pulse' 
                    : draggingSection && dropzoneContents['bottom-left'] !== draggingSection
                    ? 'border-green-300 bg-green-500/5 shadow-lg shadow-green-500/10'
                    : scanSuccess
                    ? 'border-green-500 bg-white/5'
                    : scanError
                    ? 'border-red-500 bg-red-500/10'
                    : scanRemoved
                    ? 'border-red-500 bg-white/5'
                    : 'border-[#3A86B6] bg-white/5'
                }`}
                style={{
                  transition: resizingZone === 'bottom-left' ? 'none' : 'all 0.3s ease'
                }}
              >
                {/* Preview placeholder when dragging over */}
                {dragOverZone === 'bottom-left' && draggingSection && dropzoneContents['bottom-left'] !== draggingSection && (
                  <motion.div
                    initial={{ opacity: 0, scale: 0.8 }}
                    animate={{ opacity: 0.5, scale: dragTransform.scale }}
                    exit={{ opacity: 0, scale: 0.8 }}
                    transition={{ duration: 0.2 }}
                    className="absolute inset-0 flex items-center justify-center pointer-events-none z-10"
                  >
                    <div className={`${
                      draggingSection === 'itemsToPick' ? 'bg-[#3A86B6]/20 border-[#4A96C6]' :
                      draggingSection === 'completedItems' ? 'bg-green-500/20 border-green-400' :
                      'bg-purple-500/20 border-purple-400'
                    } border-2 border-dashed rounded-xl w-[85%] h-[85%] flex items-center justify-center`}>
                      <span className="text-white/50 text-lg font-semibold">Drop here</span>
                    </div>
                  </motion.div>
                )}
                
                {dropzoneContents['bottom-left'] && (() => {
                  const sectionId = dropzoneContents['bottom-left'];
                  const config = getSectionConfig(sectionId);
                  if (!config || !config.visible) return null;

                  return (
                      <motion.div
                        key={sectionId}
                        drag={!isInteractingWithItem}
                        dragSnapToOrigin
                        dragMomentum={false}
                        dragConstraints={{
                          left: -window.innerWidth * 0.8,
                          right: window.innerWidth * 0.8,
                          top: -window.innerHeight * 0.8,
                          bottom: window.innerHeight * 0.8
                        }}
                        dragElastic={0.2}
                        dragTransition={{ bounceStiffness: 600, bounceDamping: 30 }}
                        className={`relative ${draggingSection === sectionId ? 'dragging-active' : 'z-10'}`}
                        whileDrag={{
                          scale: draggingSection === sectionId ? dragTransform.scale : 1,
                          opacity: 0.9,
                          boxShadow: "0 25px 50px -12px rgba(0, 0, 0, 0.5), 0 0 0 2px rgba(59, 130, 246, 0.5)",
                          // cursor handled by custom cursor system
                        }}
                        ref={(el) => {
                          if (el) dragElementRefs.current[sectionId] = el;
                        }}
                        data-draggable="true"
                        layoutId={sectionId}
                        initial={false}
                        animate={{
                          opacity: 1
                        }}
                        transition={{ 
                          layout: { duration: 0.2, ease: "easeOut" },
                          opacity: { duration: 0.1 }
                        }}
                        onDragStart={() => {
                          if (isInteractingWithItem) {
                            console.log('Drag blocked - isInteractingWithItem is true');
                            return;
                          }
                          setDraggingSection(sectionId);
                          playSound('click');
                          // Set custom cursor to dragging state
                          if (window.customCursor) {
                            window.customCursor.setDragging(true);
                          }
                        }}
                        onDrag={(event, info) => {
                          if (!isInteractingWithItem) {
                            // Get current pointer/drag position
                            const pointerX = event.clientX || (event.touches && event.touches[0]?.clientX) || 0;
                            const pointerY = event.clientY || (event.touches && event.touches[0]?.clientY) || 0;
                            
                            // Find which dropzone we're over
                            const dropzones = document.querySelectorAll('[data-dropzone]');
                            let targetZone = null;
                            
                            dropzones.forEach(zone => {
                              const zoneRect = zone.getBoundingClientRect();
                              if (pointerX >= zoneRect.left && pointerX <= zoneRect.right &&
                                  pointerY >= zoneRect.top && pointerY <= zoneRect.bottom) {
                                const zoneId = zone.getAttribute('data-dropzone');
                                // Only highlight if this section can be dropped here (not its current zone)
                                if (dropzoneContents[zoneId] !== sectionId) {
                                  targetZone = zoneId;
                                }
                              }
                            });
                            
                            setDragOverZone(targetZone);
                            
                            // Update transform when over a zone
                            if (targetZone) {
                              const transform = getDropzoneTransform(targetZone, getCurrentZone(sectionId), sectionId);
                              setDragTransform(transform);
                            } else {
                              setDragTransform({ scale: 1.05, x: 0, y: 0 });
                            }
                          }
                        }}
                        onDragEnd={(event, info) => {
                          const shouldSnapBack = !handleDragEndWithZoneDetection(event, info, sectionId);
                          if (shouldSnapBack) {
                            // Force snap back to origin for same-zone drops
                            const element = dragElementRefs.current[sectionId];
                            if (element) {
                              element.style.transform = 'translate3d(0px, 0px, 0px)';
                            }
                          }
                          // Reset custom cursor dragging state
                          if (window.customCursor) {
                            window.customCursor.setDragging(false);
                          }
                        }}
                      >
                        <div className={`h-full w-full flex flex-col transition-all duration-300`}>
                          <motion.button
                            onClick={() => {
                              // Prevent toggling show/hide when dragging
                              if (!draggingSection) {
                                config.setShow(!config.show);
                                playSound('click');
                              }
                            }}
                            className={`flex items-center justify-between w-full p-3 transition-all duration-300 ${!isInteractingWithItem ? 'cursor-move' : 'cursor-pointer'} relative overflow-hidden`}
                            whileHover={{ scale: 1.01 }}
                            whileTap={{ scale: 0.99 }}
                            style={{ 
                              opacity: isInteractingWithItem ? 0.7 : 1,
                              pointerEvents: 'auto'
                            }}
                          >
                            {/* Gradient overlay effects */}
                            {sectionId === 'completedItems' && (
                              <div className="absolute inset-0 bg-gradient-to-br from-green-500/0 via-green-500/0 to-green-500/0 group-hover:from-green-500/10 group-hover:via-green-500/5 group-hover:to-green-500/10 rounded-xl transition-all duration-500" />
                            )}
                            {renderSectionContent(sectionId)}
                            <div className="flex items-center space-x-2">
                              {/* Refresh button */}
                              <motion.div
                                onClick={(e) => {
                                  e.stopPropagation();
                                  handleRefreshSection(sectionId);
                                }}
                                className={`p-1.5 rounded-lg ${config.bgColor} hover:bg-white/10 transition-all duration-200 cursor-pointer`}
                                whileHover={{ scale: 1.1 }}
                                whileTap={{ scale: 0.9 }}
                                title="Refresh section"
                              >
                                <RefreshCw className={config.chevronColor} size={18} />
                              </motion.div>
                              
                              <span className={`${config.chevronColor} text-sm font-medium opacity-80`}>
                                {config.show ? 'Hide' : 'Show'}
                              </span>
                              <motion.div
                                animate={{ rotate: config.show ? 180 : 0 }}
                                transition={{ duration: 0.2 }}
                              >
                                {config.show ? (
                                  <ChevronUp className={config.chevronColor} size={20} />
                                ) : (
                                  <ChevronDown className={config.chevronColor} size={20} />
                                )}
                              </motion.div>
                            </div>
                          </motion.button>
                          
                          <AnimatePresence mode="wait">
                            {config.show && config.content && (
                              <motion.div 
                                className={`flex-1 ${config.bgColor} border-l border-r border-b rounded-xl overflow-hidden flex flex-col relative`}
                                initial={{ opacity: 0 }}
                                animate={{ opacity: 1 }}
                                exit={{ opacity: 0 }}
                                transition={{ 
                                  opacity: { duration: 0.2, ease: "easeOut" }
                                }}
                                layout={false}
                                style={{ 
                                  maxHeight: config.show ? '9999px' : '0',
                                  transition: 'max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1)'
                                }}
                                onPointerDown={(e) => e.stopPropagation()}
                                onMouseDown={(e) => e.stopPropagation()}
                                onDragStart={(e) => e.preventDefault()}
                              >
                                {/* Gradient overlay effects for content area */}
                                {sectionId === 'completedItems' && (
                                  <div className="absolute inset-0 bg-gradient-to-br from-green-500/0 via-green-500/0 to-green-500/0 group-hover:from-green-500/10 group-hover:via-green-500/5 group-hover:to-green-500/10 rounded-xl transition-all duration-500 pointer-events-none" />
                                )}
                                <motion.div 
                                  className="flex-1 overflow-auto relative z-10"
                                  initial={{ opacity: 0, y: -10 }}
                                  animate={{ opacity: 1, y: 0 }}
                                  exit={{ opacity: 0, y: -10 }}
                                  transition={{ duration: 0.2, delay: 0.1 }}
                                >
                                  {config.content}
                                </motion.div>
                              </motion.div>
                            )}
                          </AnimatePresence>
                        </div>
                      </motion.div>
                  );
                })()}
              </div>
            </motion.div>
            )}
            
            {/* Metrics Dropzone - Hide when it contains completed items with no items */}
            {!(dropzoneContents['bottom-right'] === 'completedItems' && completedItems.length === 0) && (
            <motion.div 
              className={`${!allSectionsMinimized && (!dropzoneContents['bottom-left'] || (dropzoneContents['bottom-left'] === 'completedItems' && completedItems.length === 0)) ? 'lg:col-span-2' : ''}`}
              initial={false}
              animate={{ opacity: 1 }}
              transition={{ duration: 0.3, ease: "easeInOut" }}>
              <div 
                data-dropzone="bottom-right"
                className={`border-2 ${allSectionsMinimized ? 'border-solid' : 'border-dashed'} rounded-2xl p-4 backdrop-blur-sm relative transition-all duration-300 flex flex-col ${
                  dragOverZone === 'bottom-right' 
                    ? 'border-purple-400 bg-purple-500/20 shadow-2xl shadow-purple-500/30 animate-pulse' 
                    : draggingSection && dropzoneContents['bottom-right'] !== draggingSection
                    ? 'border-purple-300 bg-purple-500/5 shadow-lg shadow-purple-500/10'
                    : scanSuccess
                    ? 'border-green-500 bg-white/5'
                    : scanError
                    ? 'border-red-500 bg-red-500/10'
                    : scanRemoved
                    ? 'border-red-500 bg-white/5'
                    : 'border-[#3A86B6] bg-white/5'
                }`}
                style={{
                  transition: resizingZone === 'bottom-right' ? 'none' : 'all 0.3s ease'
                }}
              >
                {/* Preview placeholder when dragging over */}
                {dragOverZone === 'bottom-right' && draggingSection && dropzoneContents['bottom-right'] !== draggingSection && (
                  <motion.div
                    initial={{ opacity: 0, scale: 0.8 }}
                    animate={{ opacity: 0.5, scale: dragTransform.scale }}
                    exit={{ opacity: 0, scale: 0.8 }}
                    transition={{ duration: 0.2 }}
                    className="absolute inset-0 flex items-center justify-center pointer-events-none z-10"
                  >
                    <div className={`${
                      draggingSection === 'itemsToPick' ? 'bg-[#3A86B6]/20 border-[#4A96C6]' :
                      draggingSection === 'completedItems' ? 'bg-green-500/20 border-green-400' :
                      'bg-purple-500/20 border-purple-400'
                    } border-2 border-dashed rounded-xl w-[85%] h-[85%] flex items-center justify-center`}>
                      <span className="text-white/50 text-lg font-semibold">Drop here</span>
                    </div>
                  </motion.div>
                )}
                
                {dropzoneContents['bottom-right'] && (() => {
                  const sectionId = dropzoneContents['bottom-right'];
                  const config = getSectionConfig(sectionId);
                  if (!config || !config.visible) return null;

                  return (
                      <motion.div
                        key={sectionId}
                        drag={!isInteractingWithItem}
                        dragSnapToOrigin
                        dragMomentum={false}
                        dragConstraints={{
                          left: -window.innerWidth * 0.8,
                          right: window.innerWidth * 0.8,
                          top: -window.innerHeight * 0.8,
                          bottom: window.innerHeight * 0.8
                        }}
                        dragElastic={0.2}
                        dragTransition={{ bounceStiffness: 600, bounceDamping: 30 }}
                        className={`relative ${draggingSection === sectionId ? 'dragging-active' : 'z-10'}`}
                        whileDrag={{
                          scale: draggingSection === sectionId ? dragTransform.scale : 1,
                          opacity: 0.9,
                          boxShadow: "0 25px 50px -12px rgba(0, 0, 0, 0.5), 0 0 0 2px rgba(59, 130, 246, 0.5)",
                          // cursor handled by custom cursor system
                        }}
                        ref={(el) => {
                          if (el) dragElementRefs.current[sectionId] = el;
                        }}
                        data-draggable="true"
                        layoutId={sectionId}
                        initial={false}
                        animate={{
                          opacity: 1
                        }}
                        transition={{ 
                          layout: { duration: 0.2, ease: "easeOut" },
                          opacity: { duration: 0.1 }
                        }}
                        onDragStart={() => {
                          if (isInteractingWithItem) {
                            console.log('Drag blocked - isInteractingWithItem is true');
                            return;
                          }
                          setDraggingSection(sectionId);
                          playSound('click');
                          // Set custom cursor to dragging state
                          if (window.customCursor) {
                            window.customCursor.setDragging(true);
                          }
                        }}
                        onDrag={(event, info) => {
                          if (!isInteractingWithItem) {
                            // Get current pointer/drag position
                            const pointerX = event.clientX || (event.touches && event.touches[0]?.clientX) || 0;
                            const pointerY = event.clientY || (event.touches && event.touches[0]?.clientY) || 0;
                            
                            // Find which dropzone we're over
                            const dropzones = document.querySelectorAll('[data-dropzone]');
                            let targetZone = null;
                            
                            dropzones.forEach(zone => {
                              const zoneRect = zone.getBoundingClientRect();
                              if (pointerX >= zoneRect.left && pointerX <= zoneRect.right &&
                                  pointerY >= zoneRect.top && pointerY <= zoneRect.bottom) {
                                const zoneId = zone.getAttribute('data-dropzone');
                                // Only highlight if this section can be dropped here (not its current zone)
                                if (dropzoneContents[zoneId] !== sectionId) {
                                  targetZone = zoneId;
                                }
                              }
                            });
                            
                            setDragOverZone(targetZone);
                            
                            // Update transform when over a zone
                            if (targetZone) {
                              const transform = getDropzoneTransform(targetZone, getCurrentZone(sectionId), sectionId);
                              setDragTransform(transform);
                            } else {
                              setDragTransform({ scale: 1.05, x: 0, y: 0 });
                            }
                          }
                        }}
                        onDragEnd={(event, info) => {
                          const shouldSnapBack = !handleDragEndWithZoneDetection(event, info, sectionId);
                          if (shouldSnapBack) {
                            // Force snap back to origin for same-zone drops
                            const element = dragElementRefs.current[sectionId];
                            if (element) {
                              element.style.transform = 'translate3d(0px, 0px, 0px)';
                            }
                          }
                          // Reset custom cursor dragging state
                          if (window.customCursor) {
                            window.customCursor.setDragging(false);
                          }
                        }}
                      >
                        <div className={`h-full w-full flex flex-col transition-all duration-300`}>
                          <motion.button
                            onClick={() => {
                              // Prevent toggling show/hide when dragging
                              if (!draggingSection) {
                                config.setShow(!config.show);
                                playSound('click');
                              }
                            }}
                            className={`flex items-center justify-between w-full p-3 transition-all duration-300 ${!isInteractingWithItem ? 'cursor-move' : 'cursor-pointer'} relative overflow-hidden`}
                            whileHover={{ scale: 1.01 }}
                            whileTap={{ scale: 0.99 }}
                            style={{ 
                              opacity: isInteractingWithItem ? 0.7 : 1,
                              pointerEvents: 'auto'
                            }}
                          >
                            {/* Gradient overlay effects */}
                            {sectionId === 'metrics' && (
                              <div className="absolute inset-0 bg-gradient-to-br from-purple-500/0 via-purple-500/0 to-purple-500/0 group-hover:from-purple-500/10 group-hover:via-purple-500/5 group-hover:to-purple-500/10 rounded-xl transition-all duration-500" />
                            )}
                            {renderSectionContent(sectionId)}
                            <div className="flex items-center space-x-2">
                              {/* Refresh button */}
                              <motion.div
                                onClick={(e) => {
                                  e.stopPropagation();
                                  handleRefreshSection(sectionId);
                                }}
                                className={`p-1.5 rounded-lg ${config.bgColor} hover:bg-white/10 transition-all duration-200 cursor-pointer`}
                                whileHover={{ scale: 1.1 }}
                                whileTap={{ scale: 0.9 }}
                                title="Refresh section"
                              >
                                <RefreshCw className={config.chevronColor} size={18} />
                              </motion.div>
                              
                              <span className={`${config.chevronColor} text-sm font-medium opacity-80`}>
                                {config.show ? 'Hide' : 'Show'}
                              </span>
                              <motion.div
                                animate={{ rotate: config.show ? 180 : 0 }}
                                transition={{ duration: 0.2 }}
                              >
                                {config.show ? (
                                  <ChevronUp className={config.chevronColor} size={20} />
                                ) : (
                                  <ChevronDown className={config.chevronColor} size={20} />
                                )}
                              </motion.div>
                            </div>
                          </motion.button>
                          
                          <AnimatePresence mode="wait">
                            {config.show && config.content && (
                              <motion.div 
                                className={`flex-1 ${config.bgColor} border-l border-r border-b rounded-xl overflow-hidden flex flex-col relative`}
                                initial={{ opacity: 0 }}
                                animate={{ opacity: 1 }}
                                exit={{ opacity: 0 }}
                                transition={{ 
                                  opacity: { duration: 0.2, ease: "easeOut" }
                                }}
                                layout={false}
                                style={{ 
                                  maxHeight: config.show ? '9999px' : '0',
                                  transition: 'max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1)'
                                }}
                                onPointerDown={(e) => e.stopPropagation()}
                                onMouseDown={(e) => e.stopPropagation()}
                                onDragStart={(e) => e.preventDefault()}
                              >
                                {/* Gradient overlay effects for content area */}
                                {sectionId === 'metrics' && (
                                  <div className="absolute inset-0 bg-gradient-to-br from-purple-500/0 via-purple-500/0 to-purple-500/0 group-hover:from-purple-500/10 group-hover:via-purple-500/5 group-hover:to-purple-500/10 rounded-xl transition-all duration-500 pointer-events-none" />
                                )}
                                <motion.div 
                                  className="flex-1 overflow-auto relative z-10"
                                  initial={{ opacity: 0, y: -10 }}
                                  animate={{ opacity: 1, y: 0 }}
                                  exit={{ opacity: 0, y: -10 }}
                                  transition={{ duration: 0.2, delay: 0.1 }}
                                >
                                  {config.content}
                                </motion.div>
                              </motion.div>
                            )}
                          </AnimatePresence>
                        </div>
                      </motion.div>
                  );
                })()}
              </div>
            </motion.div>
            )}
            
            
            {allItemsPicked && (
              <div className="lg:col-span-2 absolute bottom-4 left-1/2 transform -translate-x-1/2 z-50">
                <div className="inline-flex items-center justify-center space-x-2 text-green-400 animate-pulse bg-gray-900/90 backdrop-blur px-6 py-3 rounded-full border border-green-500/50">
                  <CheckCircle size={28} />
                  <span className="text-xl font-semibold">All items picked! Completing order...</span>
                </div>
              </div>
            )}
            </motion.div>
        </div>
      </div>
    </div>
  );
});

PickingScreen.displayName = 'PickingScreen';

export default PickingScreen;